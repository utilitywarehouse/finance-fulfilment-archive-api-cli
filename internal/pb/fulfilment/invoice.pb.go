// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: invoice.proto

package fulfilment

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Invoice struct {
	Id                   string                  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Date                 string                  `protobuf:"bytes,2,opt,name=date,proto3" json:"date,omitempty"`
	InvoicePeriod        string                  `protobuf:"bytes,3,opt,name=invoice_period,json=invoicePeriod,proto3" json:"invoice_period,omitempty"`
	PaymentMethod        string                  `protobuf:"bytes,4,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty"`
	Account              *Account                `protobuf:"bytes,5,opt,name=account,proto3" json:"account,omitempty"`
	InvoiceSummary       *Aggregation            `protobuf:"bytes,6,opt,name=invoice_summary,json=invoiceSummary,proto3" json:"invoice_summary,omitempty"`
	InvoiceBreakdown     []*InvoiceBreakdownItem `protobuf:"bytes,7,rep,name=invoice_breakdown,json=invoiceBreakdown,proto3" json:"invoice_breakdown,omitempty"`
	HighlightedBreakdown *Aggregation            `protobuf:"bytes,8,opt,name=highlighted_breakdown,json=highlightedBreakdown,proto3" json:"highlighted_breakdown,omitempty"`
	ProductGroups        []*ProductGroup         `protobuf:"bytes,9,rep,name=product_groups,json=productGroups,proto3" json:"product_groups,omitempty"`
	CreditsAndDebits     *Section                `protobuf:"bytes,10,opt,name=credits_and_debits,json=creditsAndDebits,proto3" json:"credits_and_debits,omitempty"`
	InfoMessages         []*Asset                `protobuf:"bytes,11,rep,name=info_messages,json=infoMessages,proto3" json:"info_messages,omitempty"`
	Assets               []*Asset                `protobuf:"bytes,12,rep,name=assets,proto3" json:"assets,omitempty"`
	Addons               []string                `protobuf:"bytes,13,rep,name=addons,proto3" json:"addons,omitempty"`
	Itemisation          *ItemisationSection     `protobuf:"bytes,14,opt,name=itemisation,proto3" json:"itemisation,omitempty"`
}

func (m *Invoice) Reset()      { *m = Invoice{} }
func (*Invoice) ProtoMessage() {}
func (*Invoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{0}
}
func (m *Invoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Invoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Invoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Invoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Invoice.Merge(m, src)
}
func (m *Invoice) XXX_Size() int {
	return m.Size()
}
func (m *Invoice) XXX_DiscardUnknown() {
	xxx_messageInfo_Invoice.DiscardUnknown(m)
}

var xxx_messageInfo_Invoice proto.InternalMessageInfo

func (m *Invoice) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Invoice) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *Invoice) GetInvoicePeriod() string {
	if m != nil {
		return m.InvoicePeriod
	}
	return ""
}

func (m *Invoice) GetPaymentMethod() string {
	if m != nil {
		return m.PaymentMethod
	}
	return ""
}

func (m *Invoice) GetAccount() *Account {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *Invoice) GetInvoiceSummary() *Aggregation {
	if m != nil {
		return m.InvoiceSummary
	}
	return nil
}

func (m *Invoice) GetInvoiceBreakdown() []*InvoiceBreakdownItem {
	if m != nil {
		return m.InvoiceBreakdown
	}
	return nil
}

func (m *Invoice) GetHighlightedBreakdown() *Aggregation {
	if m != nil {
		return m.HighlightedBreakdown
	}
	return nil
}

func (m *Invoice) GetProductGroups() []*ProductGroup {
	if m != nil {
		return m.ProductGroups
	}
	return nil
}

func (m *Invoice) GetCreditsAndDebits() *Section {
	if m != nil {
		return m.CreditsAndDebits
	}
	return nil
}

func (m *Invoice) GetInfoMessages() []*Asset {
	if m != nil {
		return m.InfoMessages
	}
	return nil
}

func (m *Invoice) GetAssets() []*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *Invoice) GetAddons() []string {
	if m != nil {
		return m.Addons
	}
	return nil
}

func (m *Invoice) GetItemisation() *ItemisationSection {
	if m != nil {
		return m.Itemisation
	}
	return nil
}

type Account struct {
	Id                 string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	AccountHolder      *AccountHolder `protobuf:"bytes,2,opt,name=account_holder,json=accountHolder,proto3" json:"account_holder,omitempty"`
	JoinDate           string         `protobuf:"bytes,3,opt,name=join_date,json=joinDate,proto3" json:"join_date,omitempty"`
	InvoicePayDate     string         `protobuf:"bytes,4,opt,name=invoice_pay_date,json=invoicePayDate,proto3" json:"invoice_pay_date,omitempty"`
	BillingAddress     *Address       `protobuf:"bytes,5,opt,name=billing_address,json=billingAddress,proto3" json:"billing_address,omitempty"`
	OutstandingBalance *Section       `protobuf:"bytes,6,opt,name=outstanding_balance,json=outstandingBalance,proto3" json:"outstanding_balance,omitempty"`
	Assets             []*Asset       `protobuf:"bytes,7,rep,name=assets,proto3" json:"assets,omitempty"`
}

func (m *Account) Reset()      { *m = Account{} }
func (*Account) ProtoMessage() {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{1}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Account) GetAccountHolder() *AccountHolder {
	if m != nil {
		return m.AccountHolder
	}
	return nil
}

func (m *Account) GetJoinDate() string {
	if m != nil {
		return m.JoinDate
	}
	return ""
}

func (m *Account) GetInvoicePayDate() string {
	if m != nil {
		return m.InvoicePayDate
	}
	return ""
}

func (m *Account) GetBillingAddress() *Address {
	if m != nil {
		return m.BillingAddress
	}
	return nil
}

func (m *Account) GetOutstandingBalance() *Section {
	if m != nil {
		return m.OutstandingBalance
	}
	return nil
}

func (m *Account) GetAssets() []*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

type AccountHolder struct {
	Title              string   `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	AltName            []string `protobuf:"bytes,5,rep,name=alt_name,json=altName,proto3" json:"alt_name,omitempty"`
	CorrespondenceName string   `protobuf:"bytes,6,opt,name=correspondence_name,json=correspondenceName,proto3" json:"correspondence_name,omitempty"`
	Email              string   `protobuf:"bytes,7,opt,name=email,proto3" json:"email,omitempty"`
	Phone              string   `protobuf:"bytes,8,opt,name=phone,proto3" json:"phone,omitempty"`
	FullName           string   `protobuf:"bytes,9,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
}

func (m *AccountHolder) Reset()      { *m = AccountHolder{} }
func (*AccountHolder) ProtoMessage() {}
func (*AccountHolder) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{2}
}
func (m *AccountHolder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountHolder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountHolder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountHolder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountHolder.Merge(m, src)
}
func (m *AccountHolder) XXX_Size() int {
	return m.Size()
}
func (m *AccountHolder) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountHolder.DiscardUnknown(m)
}

var xxx_messageInfo_AccountHolder proto.InternalMessageInfo

func (m *AccountHolder) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AccountHolder) GetAltName() []string {
	if m != nil {
		return m.AltName
	}
	return nil
}

func (m *AccountHolder) GetCorrespondenceName() string {
	if m != nil {
		return m.CorrespondenceName
	}
	return ""
}

func (m *AccountHolder) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *AccountHolder) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *AccountHolder) GetFullName() string {
	if m != nil {
		return m.FullName
	}
	return ""
}

type Address struct {
	Postcode     string   `protobuf:"bytes,1,opt,name=postcode,proto3" json:"postcode,omitempty"`
	AddressLines []string `protobuf:"bytes,2,rep,name=address_lines,json=addressLines,proto3" json:"address_lines,omitempty"`
}

func (m *Address) Reset()      { *m = Address{} }
func (*Address) ProtoMessage() {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{3}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Address.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(m, src)
}
func (m *Address) XXX_Size() int {
	return m.Size()
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

func (m *Address) GetPostcode() string {
	if m != nil {
		return m.Postcode
	}
	return ""
}

func (m *Address) GetAddressLines() []string {
	if m != nil {
		return m.AddressLines
	}
	return nil
}

type Aggregation struct {
	Description string      `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Items       []*CostItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
	Total       *Total      `protobuf:"bytes,3,opt,name=total,proto3" json:"total,omitempty"`
	Type        string      `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *Aggregation) Reset()      { *m = Aggregation{} }
func (*Aggregation) ProtoMessage() {}
func (*Aggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{4}
}
func (m *Aggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregation.Merge(m, src)
}
func (m *Aggregation) XXX_Size() int {
	return m.Size()
}
func (m *Aggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregation.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregation proto.InternalMessageInfo

func (m *Aggregation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Aggregation) GetItems() []*CostItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Aggregation) GetTotal() *Total {
	if m != nil {
		return m.Total
	}
	return nil
}

func (m *Aggregation) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type Section struct {
	Description  string         `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Summary      []*Aggregation `protobuf:"bytes,2,rep,name=summary,proto3" json:"summary,omitempty"`
	Assets       []*Asset       `protobuf:"bytes,3,rep,name=assets,proto3" json:"assets,omitempty"`
	InfoMessages []*Asset       `protobuf:"bytes,4,rep,name=info_messages,json=infoMessages,proto3" json:"info_messages,omitempty"`
	Total        *Total         `protobuf:"bytes,5,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *Section) Reset()      { *m = Section{} }
func (*Section) ProtoMessage() {}
func (*Section) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{5}
}
func (m *Section) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Section) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Section.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Section) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Section.Merge(m, src)
}
func (m *Section) XXX_Size() int {
	return m.Size()
}
func (m *Section) XXX_DiscardUnknown() {
	xxx_messageInfo_Section.DiscardUnknown(m)
}

var xxx_messageInfo_Section proto.InternalMessageInfo

func (m *Section) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Section) GetSummary() []*Aggregation {
	if m != nil {
		return m.Summary
	}
	return nil
}

func (m *Section) GetAssets() []*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *Section) GetInfoMessages() []*Asset {
	if m != nil {
		return m.InfoMessages
	}
	return nil
}

func (m *Section) GetTotal() *Total {
	if m != nil {
		return m.Total
	}
	return nil
}

type CostItem struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Date        string `protobuf:"bytes,2,opt,name=date,proto3" json:"date,omitempty"`
	Cost        *Total `protobuf:"bytes,3,opt,name=cost,proto3" json:"cost,omitempty"`
	Type        string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Icon        *Asset `protobuf:"bytes,5,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *CostItem) Reset()      { *m = CostItem{} }
func (*CostItem) ProtoMessage() {}
func (*CostItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{6}
}
func (m *CostItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CostItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CostItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CostItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CostItem.Merge(m, src)
}
func (m *CostItem) XXX_Size() int {
	return m.Size()
}
func (m *CostItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CostItem.DiscardUnknown(m)
}

var xxx_messageInfo_CostItem proto.InternalMessageInfo

func (m *CostItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CostItem) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *CostItem) GetCost() *Total {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *CostItem) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CostItem) GetIcon() *Asset {
	if m != nil {
		return m.Icon
	}
	return nil
}

type UsageItem struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Usage       *Usage `protobuf:"bytes,2,opt,name=usage,proto3" json:"usage,omitempty"`
}

func (m *UsageItem) Reset()      { *m = UsageItem{} }
func (*UsageItem) ProtoMessage() {}
func (*UsageItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{7}
}
func (m *UsageItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem.Merge(m, src)
}
func (m *UsageItem) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem proto.InternalMessageInfo

func (m *UsageItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *UsageItem) GetUsage() *Usage {
	if m != nil {
		return m.Usage
	}
	return nil
}

type Item struct {
	Description string          `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Start       *Item_Event     `protobuf:"bytes,2,opt,name=start,proto3" json:"start,omitempty"`
	End         *Item_Event     `protobuf:"bytes,3,opt,name=end,proto3" json:"end,omitempty"`
	Usage       *Usage          `protobuf:"bytes,4,opt,name=usage,proto3" json:"usage,omitempty"`
	AltUsage    *AlternateUsage `protobuf:"bytes,5,opt,name=alt_usage,json=altUsage,proto3" json:"alt_usage,omitempty"`
	Cost        *Amount         `protobuf:"bytes,6,opt,name=cost,proto3" json:"cost,omitempty"`
	Prepaid     bool            `protobuf:"varint,7,opt,name=prepaid,proto3" json:"prepaid,omitempty"`
	Type        *Item_Type      `protobuf:"bytes,8,opt,name=type,proto3" json:"type,omitempty"`
	Rate        *Rate           `protobuf:"bytes,9,opt,name=rate,proto3" json:"rate,omitempty"`
	Destination string          `protobuf:"bytes,10,opt,name=Destination,proto3" json:"Destination,omitempty"`
}

func (m *Item) Reset()      { *m = Item{} }
func (*Item) ProtoMessage() {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{8}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Item) GetStart() *Item_Event {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Item) GetEnd() *Item_Event {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *Item) GetUsage() *Usage {
	if m != nil {
		return m.Usage
	}
	return nil
}

func (m *Item) GetAltUsage() *AlternateUsage {
	if m != nil {
		return m.AltUsage
	}
	return nil
}

func (m *Item) GetCost() *Amount {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *Item) GetPrepaid() bool {
	if m != nil {
		return m.Prepaid
	}
	return false
}

func (m *Item) GetType() *Item_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Item) GetRate() *Rate {
	if m != nil {
		return m.Rate
	}
	return nil
}

func (m *Item) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type Item_Event struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Usage       *Usage `protobuf:"bytes,2,opt,name=usage,proto3" json:"usage,omitempty"`
	Date        string `protobuf:"bytes,3,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *Item_Event) Reset()      { *m = Item_Event{} }
func (*Item_Event) ProtoMessage() {}
func (*Item_Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{8, 0}
}
func (m *Item_Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item_Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item_Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item_Event.Merge(m, src)
}
func (m *Item_Event) XXX_Size() int {
	return m.Size()
}
func (m *Item_Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Item_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Item_Event proto.InternalMessageInfo

func (m *Item_Event) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Item_Event) GetUsage() *Usage {
	if m != nil {
		return m.Usage
	}
	return nil
}

func (m *Item_Event) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

type Item_Type struct {
	ItemType            string `protobuf:"bytes,1,opt,name=itemType,proto3" json:"itemType,omitempty"`
	UsageClassification string `protobuf:"bytes,2,opt,name=usageClassification,proto3" json:"usageClassification,omitempty"`
}

func (m *Item_Type) Reset()      { *m = Item_Type{} }
func (*Item_Type) ProtoMessage() {}
func (*Item_Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{8, 1}
}
func (m *Item_Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item_Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item_Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item_Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item_Type.Merge(m, src)
}
func (m *Item_Type) XXX_Size() int {
	return m.Size()
}
func (m *Item_Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Item_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Item_Type proto.InternalMessageInfo

func (m *Item_Type) GetItemType() string {
	if m != nil {
		return m.ItemType
	}
	return ""
}

func (m *Item_Type) GetUsageClassification() string {
	if m != nil {
		return m.UsageClassification
	}
	return ""
}

type InvoiceBreakdownItem struct {
	Description string  `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Type        string  `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Cost        *Amount `protobuf:"bytes,3,opt,name=cost,proto3" json:"cost,omitempty"`
	Asset       *Asset  `protobuf:"bytes,4,opt,name=asset,proto3" json:"asset,omitempty"`
}

func (m *InvoiceBreakdownItem) Reset()      { *m = InvoiceBreakdownItem{} }
func (*InvoiceBreakdownItem) ProtoMessage() {}
func (*InvoiceBreakdownItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{9}
}
func (m *InvoiceBreakdownItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvoiceBreakdownItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvoiceBreakdownItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InvoiceBreakdownItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvoiceBreakdownItem.Merge(m, src)
}
func (m *InvoiceBreakdownItem) XXX_Size() int {
	return m.Size()
}
func (m *InvoiceBreakdownItem) XXX_DiscardUnknown() {
	xxx_messageInfo_InvoiceBreakdownItem.DiscardUnknown(m)
}

var xxx_messageInfo_InvoiceBreakdownItem proto.InternalMessageInfo

func (m *InvoiceBreakdownItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *InvoiceBreakdownItem) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InvoiceBreakdownItem) GetCost() *Amount {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *InvoiceBreakdownItem) GetAsset() *Asset {
	if m != nil {
		return m.Asset
	}
	return nil
}

type ItemisationSection struct {
	Description string              `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Assets      []*Asset            `protobuf:"bytes,2,rep,name=assets,proto3" json:"assets,omitempty"`
	Groups      []*ItemisationGroup `protobuf:"bytes,3,rep,name=groups,proto3" json:"groups,omitempty"`
}

func (m *ItemisationSection) Reset()      { *m = ItemisationSection{} }
func (*ItemisationSection) ProtoMessage() {}
func (*ItemisationSection) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{10}
}
func (m *ItemisationSection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemisationSection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemisationSection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemisationSection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemisationSection.Merge(m, src)
}
func (m *ItemisationSection) XXX_Size() int {
	return m.Size()
}
func (m *ItemisationSection) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemisationSection.DiscardUnknown(m)
}

var xxx_messageInfo_ItemisationSection proto.InternalMessageInfo

func (m *ItemisationSection) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ItemisationSection) GetAssets() []*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *ItemisationSection) GetGroups() []*ItemisationGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

type ItemisationGroup struct {
	Type        string                     `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Description string                     `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Assets      []*Asset                   `protobuf:"bytes,3,rep,name=assets,proto3" json:"assets,omitempty"`
	Elements    []*ItemisationGroupElement `protobuf:"bytes,4,rep,name=elements,proto3" json:"elements,omitempty"`
}

func (m *ItemisationGroup) Reset()      { *m = ItemisationGroup{} }
func (*ItemisationGroup) ProtoMessage() {}
func (*ItemisationGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{11}
}
func (m *ItemisationGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemisationGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemisationGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemisationGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemisationGroup.Merge(m, src)
}
func (m *ItemisationGroup) XXX_Size() int {
	return m.Size()
}
func (m *ItemisationGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemisationGroup.DiscardUnknown(m)
}

var xxx_messageInfo_ItemisationGroup proto.InternalMessageInfo

func (m *ItemisationGroup) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ItemisationGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ItemisationGroup) GetAssets() []*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *ItemisationGroup) GetElements() []*ItemisationGroupElement {
	if m != nil {
		return m.Elements
	}
	return nil
}

type ItemisationGroupElement struct {
	Type        string  `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Label       string  `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Description string  `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Items       []*Item `protobuf:"bytes,4,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *ItemisationGroupElement) Reset()      { *m = ItemisationGroupElement{} }
func (*ItemisationGroupElement) ProtoMessage() {}
func (*ItemisationGroupElement) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{12}
}
func (m *ItemisationGroupElement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemisationGroupElement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemisationGroupElement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemisationGroupElement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemisationGroupElement.Merge(m, src)
}
func (m *ItemisationGroupElement) XXX_Size() int {
	return m.Size()
}
func (m *ItemisationGroupElement) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemisationGroupElement.DiscardUnknown(m)
}

var xxx_messageInfo_ItemisationGroupElement proto.InternalMessageInfo

func (m *ItemisationGroupElement) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ItemisationGroupElement) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *ItemisationGroupElement) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ItemisationGroupElement) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type ProductGroup struct {
	Type                string         `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Description         string         `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Assets              []*Asset       `protobuf:"bytes,3,rep,name=assets,proto3" json:"assets,omitempty"`
	Products            []*Product     `protobuf:"bytes,4,rep,name=products,proto3" json:"products,omitempty"`
	Total               *Total         `protobuf:"bytes,5,opt,name=total,proto3" json:"total,omitempty"`
	InfoMessages        []*Asset       `protobuf:"bytes,6,rep,name=info_messages,json=infoMessages,proto3" json:"info_messages,omitempty"`
	Summary             []*Aggregation `protobuf:"bytes,7,rep,name=summary,proto3" json:"summary,omitempty"`
	CreditsAndDebits    *Aggregation   `protobuf:"bytes,8,opt,name=credits_and_debits,json=creditsAndDebits,proto3" json:"credits_and_debits,omitempty"`
	OffsetToOutstanding *Aggregation   `protobuf:"bytes,9,opt,name=offset_to_outstanding,json=offsetToOutstanding,proto3" json:"offset_to_outstanding,omitempty"`
}

func (m *ProductGroup) Reset()      { *m = ProductGroup{} }
func (*ProductGroup) ProtoMessage() {}
func (*ProductGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{13}
}
func (m *ProductGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductGroup.Merge(m, src)
}
func (m *ProductGroup) XXX_Size() int {
	return m.Size()
}
func (m *ProductGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductGroup.DiscardUnknown(m)
}

var xxx_messageInfo_ProductGroup proto.InternalMessageInfo

func (m *ProductGroup) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ProductGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ProductGroup) GetAssets() []*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *ProductGroup) GetProducts() []*Product {
	if m != nil {
		return m.Products
	}
	return nil
}

func (m *ProductGroup) GetTotal() *Total {
	if m != nil {
		return m.Total
	}
	return nil
}

func (m *ProductGroup) GetInfoMessages() []*Asset {
	if m != nil {
		return m.InfoMessages
	}
	return nil
}

func (m *ProductGroup) GetSummary() []*Aggregation {
	if m != nil {
		return m.Summary
	}
	return nil
}

func (m *ProductGroup) GetCreditsAndDebits() *Aggregation {
	if m != nil {
		return m.CreditsAndDebits
	}
	return nil
}

func (m *ProductGroup) GetOffsetToOutstanding() *Aggregation {
	if m != nil {
		return m.OffsetToOutstanding
	}
	return nil
}

type Product struct {
	ProductType      string       `protobuf:"bytes,1,opt,name=product_type,json=productType,proto3" json:"product_type,omitempty"`
	Description      string       `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Label            string       `protobuf:"bytes,3,opt,name=label,proto3" json:"label,omitempty"`
	NickName         string       `protobuf:"bytes,4,opt,name=nick_name,json=nickName,proto3" json:"nick_name,omitempty"`
	Active           bool         `protobuf:"varint,5,opt,name=active,proto3" json:"active,omitempty"`
	TerminationDate  string       `protobuf:"bytes,6,opt,name=termination_date,json=terminationDate,proto3" json:"termination_date,omitempty"`
	Items            []*Item      `protobuf:"bytes,7,rep,name=items,proto3" json:"items,omitempty"`
	Tariff           *Tariff      `protobuf:"bytes,8,opt,name=tariff,proto3" json:"tariff,omitempty"`
	Supply           *Supply      `protobuf:"bytes,9,opt,name=supply,proto3" json:"supply,omitempty"`
	Histogram        []*UsageItem `protobuf:"bytes,10,rep,name=histogram,proto3" json:"histogram,omitempty"`
	Costs            *Aggregation `protobuf:"bytes,11,opt,name=costs,proto3" json:"costs,omitempty"`
	CreditsAndDebits *Aggregation `protobuf:"bytes,12,opt,name=credits_and_debits,json=creditsAndDebits,proto3" json:"credits_and_debits,omitempty"`
	BudgetPlan       *BudgetPlan  `protobuf:"bytes,13,opt,name=budget_plan,json=budgetPlan,proto3" json:"budget_plan,omitempty"`
	Total            *Total       `protobuf:"bytes,14,opt,name=total,proto3" json:"total,omitempty"`
	InfoMessages     []*Asset     `protobuf:"bytes,15,rep,name=info_messages,json=infoMessages,proto3" json:"info_messages,omitempty"`
	Assets           []*Asset     `protobuf:"bytes,16,rep,name=assets,proto3" json:"assets,omitempty"`
}

func (m *Product) Reset()      { *m = Product{} }
func (*Product) ProtoMessage() {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{14}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.Size()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetProductType() string {
	if m != nil {
		return m.ProductType
	}
	return ""
}

func (m *Product) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Product) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Product) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *Product) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Product) GetTerminationDate() string {
	if m != nil {
		return m.TerminationDate
	}
	return ""
}

func (m *Product) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Product) GetTariff() *Tariff {
	if m != nil {
		return m.Tariff
	}
	return nil
}

func (m *Product) GetSupply() *Supply {
	if m != nil {
		return m.Supply
	}
	return nil
}

func (m *Product) GetHistogram() []*UsageItem {
	if m != nil {
		return m.Histogram
	}
	return nil
}

func (m *Product) GetCosts() *Aggregation {
	if m != nil {
		return m.Costs
	}
	return nil
}

func (m *Product) GetCreditsAndDebits() *Aggregation {
	if m != nil {
		return m.CreditsAndDebits
	}
	return nil
}

func (m *Product) GetBudgetPlan() *BudgetPlan {
	if m != nil {
		return m.BudgetPlan
	}
	return nil
}

func (m *Product) GetTotal() *Total {
	if m != nil {
		return m.Total
	}
	return nil
}

func (m *Product) GetInfoMessages() []*Asset {
	if m != nil {
		return m.InfoMessages
	}
	return nil
}

func (m *Product) GetAssets() []*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

type BudgetPlan struct {
	Total                      *Total  `protobuf:"bytes,1,opt,name=total,proto3" json:"total,omitempty"`
	Balance                    *Amount `protobuf:"bytes,2,opt,name=balance,proto3" json:"balance,omitempty"`
	PreviousBalance            *Amount `protobuf:"bytes,3,opt,name=previous_balance,json=previousBalance,proto3" json:"previous_balance,omitempty"`
	BalanceDescription         string  `protobuf:"bytes,4,opt,name=balance_description,json=balanceDescription,proto3" json:"balance_description,omitempty"`
	BalanceExplanation         string  `protobuf:"bytes,5,opt,name=balance_explanation,json=balanceExplanation,proto3" json:"balance_explanation,omitempty"`
	PreviousBalanceDescription string  `protobuf:"bytes,6,opt,name=previous_balance_description,json=previousBalanceDescription,proto3" json:"previous_balance_description,omitempty"`
}

func (m *BudgetPlan) Reset()      { *m = BudgetPlan{} }
func (*BudgetPlan) ProtoMessage() {}
func (*BudgetPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{15}
}
func (m *BudgetPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BudgetPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BudgetPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BudgetPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BudgetPlan.Merge(m, src)
}
func (m *BudgetPlan) XXX_Size() int {
	return m.Size()
}
func (m *BudgetPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_BudgetPlan.DiscardUnknown(m)
}

var xxx_messageInfo_BudgetPlan proto.InternalMessageInfo

func (m *BudgetPlan) GetTotal() *Total {
	if m != nil {
		return m.Total
	}
	return nil
}

func (m *BudgetPlan) GetBalance() *Amount {
	if m != nil {
		return m.Balance
	}
	return nil
}

func (m *BudgetPlan) GetPreviousBalance() *Amount {
	if m != nil {
		return m.PreviousBalance
	}
	return nil
}

func (m *BudgetPlan) GetBalanceDescription() string {
	if m != nil {
		return m.BalanceDescription
	}
	return ""
}

func (m *BudgetPlan) GetBalanceExplanation() string {
	if m != nil {
		return m.BalanceExplanation
	}
	return ""
}

func (m *BudgetPlan) GetPreviousBalanceDescription() string {
	if m != nil {
		return m.PreviousBalanceDescription
	}
	return ""
}

type Total struct {
	Net      *Amount `protobuf:"bytes,1,opt,name=net,proto3" json:"net,omitempty"`
	VatItems []*VAT  `protobuf:"bytes,2,rep,name=vat_items,json=vatItems,proto3" json:"vat_items,omitempty"`
	Gross    *Amount `protobuf:"bytes,3,opt,name=gross,proto3" json:"gross,omitempty"`
}

func (m *Total) Reset()      { *m = Total{} }
func (*Total) ProtoMessage() {}
func (*Total) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{16}
}
func (m *Total) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Total) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Total.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Total) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Total.Merge(m, src)
}
func (m *Total) XXX_Size() int {
	return m.Size()
}
func (m *Total) XXX_DiscardUnknown() {
	xxx_messageInfo_Total.DiscardUnknown(m)
}

var xxx_messageInfo_Total proto.InternalMessageInfo

func (m *Total) GetNet() *Amount {
	if m != nil {
		return m.Net
	}
	return nil
}

func (m *Total) GetVatItems() []*VAT {
	if m != nil {
		return m.VatItems
	}
	return nil
}

func (m *Total) GetGross() *Amount {
	if m != nil {
		return m.Gross
	}
	return nil
}

type Supply struct {
	SupplyId     string   `protobuf:"bytes,1,opt,name=supply_id,json=supplyId,proto3" json:"supply_id,omitempty"`
	SerialNumber string   `protobuf:"bytes,2,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	Distributor  []string `protobuf:"bytes,3,rep,name=distributor,proto3" json:"distributor,omitempty"`
	Address      *Address `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Supply) Reset()      { *m = Supply{} }
func (*Supply) ProtoMessage() {}
func (*Supply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{17}
}
func (m *Supply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Supply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Supply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Supply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Supply.Merge(m, src)
}
func (m *Supply) XXX_Size() int {
	return m.Size()
}
func (m *Supply) XXX_DiscardUnknown() {
	xxx_messageInfo_Supply.DiscardUnknown(m)
}

var xxx_messageInfo_Supply proto.InternalMessageInfo

func (m *Supply) GetSupplyId() string {
	if m != nil {
		return m.SupplyId
	}
	return ""
}

func (m *Supply) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *Supply) GetDistributor() []string {
	if m != nil {
		return m.Distributor
	}
	return nil
}

func (m *Supply) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type Tariff struct {
	Name          string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	PaymentMethod string   `protobuf:"bytes,2,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty"`
	ExitFee       *Amount  `protobuf:"bytes,3,opt,name=exit_fee,json=exitFee,proto3" json:"exit_fee,omitempty"`
	EndDate       string   `protobuf:"bytes,4,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty"`
	Assets        []*Asset `protobuf:"bytes,5,rep,name=assets,proto3" json:"assets,omitempty"`
	Id            string   `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Tariff) Reset()      { *m = Tariff{} }
func (*Tariff) ProtoMessage() {}
func (*Tariff) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{18}
}
func (m *Tariff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tariff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tariff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tariff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tariff.Merge(m, src)
}
func (m *Tariff) XXX_Size() int {
	return m.Size()
}
func (m *Tariff) XXX_DiscardUnknown() {
	xxx_messageInfo_Tariff.DiscardUnknown(m)
}

var xxx_messageInfo_Tariff proto.InternalMessageInfo

func (m *Tariff) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tariff) GetPaymentMethod() string {
	if m != nil {
		return m.PaymentMethod
	}
	return ""
}

func (m *Tariff) GetExitFee() *Amount {
	if m != nil {
		return m.ExitFee
	}
	return nil
}

func (m *Tariff) GetEndDate() string {
	if m != nil {
		return m.EndDate
	}
	return ""
}

func (m *Tariff) GetAssets() []*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *Tariff) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Rate struct {
	Cost *Amount `protobuf:"bytes,1,opt,name=cost,proto3" json:"cost,omitempty"`
	Unit string  `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit,omitempty"`
}

func (m *Rate) Reset()      { *m = Rate{} }
func (*Rate) ProtoMessage() {}
func (*Rate) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{19}
}
func (m *Rate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rate.Merge(m, src)
}
func (m *Rate) XXX_Size() int {
	return m.Size()
}
func (m *Rate) XXX_DiscardUnknown() {
	xxx_messageInfo_Rate.DiscardUnknown(m)
}

var xxx_messageInfo_Rate proto.InternalMessageInfo

func (m *Rate) GetCost() *Amount {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *Rate) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

type Usage struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Unit  string `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit,omitempty"`
}

func (m *Usage) Reset()      { *m = Usage{} }
func (*Usage) ProtoMessage() {}
func (*Usage) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{20}
}
func (m *Usage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Usage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Usage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Usage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Usage.Merge(m, src)
}
func (m *Usage) XXX_Size() int {
	return m.Size()
}
func (m *Usage) XXX_DiscardUnknown() {
	xxx_messageInfo_Usage.DiscardUnknown(m)
}

var xxx_messageInfo_Usage proto.InternalMessageInfo

func (m *Usage) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Usage) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

type AlternateUsage struct {
	Value  string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Unit   string `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit,omitempty"`
	Factor string `protobuf:"bytes,3,opt,name=factor,proto3" json:"factor,omitempty"`
}

func (m *AlternateUsage) Reset()      { *m = AlternateUsage{} }
func (*AlternateUsage) ProtoMessage() {}
func (*AlternateUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{21}
}
func (m *AlternateUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlternateUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlternateUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlternateUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlternateUsage.Merge(m, src)
}
func (m *AlternateUsage) XXX_Size() int {
	return m.Size()
}
func (m *AlternateUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_AlternateUsage.DiscardUnknown(m)
}

var xxx_messageInfo_AlternateUsage proto.InternalMessageInfo

func (m *AlternateUsage) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *AlternateUsage) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *AlternateUsage) GetFactor() string {
	if m != nil {
		return m.Factor
	}
	return ""
}

type Amount struct {
	Value    string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Currency string `protobuf:"bytes,2,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (m *Amount) Reset()      { *m = Amount{} }
func (*Amount) ProtoMessage() {}
func (*Amount) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{22}
}
func (m *Amount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Amount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Amount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Amount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Amount.Merge(m, src)
}
func (m *Amount) XXX_Size() int {
	return m.Size()
}
func (m *Amount) XXX_DiscardUnknown() {
	xxx_messageInfo_Amount.DiscardUnknown(m)
}

var xxx_messageInfo_Amount proto.InternalMessageInfo

func (m *Amount) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Amount) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type Asset struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Content     string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	Url         string `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	Type        string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *Asset) Reset()      { *m = Asset{} }
func (*Asset) ProtoMessage() {}
func (*Asset) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{23}
}
func (m *Asset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Asset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Asset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Asset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Asset.Merge(m, src)
}
func (m *Asset) XXX_Size() int {
	return m.Size()
}
func (m *Asset) XXX_DiscardUnknown() {
	xxx_messageInfo_Asset.DiscardUnknown(m)
}

var xxx_messageInfo_Asset proto.InternalMessageInfo

func (m *Asset) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Asset) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Asset) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Asset) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type VAT struct {
	Band   string  `protobuf:"bytes,1,opt,name=band,proto3" json:"band,omitempty"`
	Amount *Amount `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *VAT) Reset()      { *m = VAT{} }
func (*VAT) ProtoMessage() {}
func (*VAT) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1832ff34ba7c07, []int{24}
}
func (m *VAT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VAT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VAT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VAT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VAT.Merge(m, src)
}
func (m *VAT) XXX_Size() int {
	return m.Size()
}
func (m *VAT) XXX_DiscardUnknown() {
	xxx_messageInfo_VAT.DiscardUnknown(m)
}

var xxx_messageInfo_VAT proto.InternalMessageInfo

func (m *VAT) GetBand() string {
	if m != nil {
		return m.Band
	}
	return ""
}

func (m *VAT) GetAmount() *Amount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func init() {
	proto.RegisterType((*Invoice)(nil), "fulfilment.Invoice")
	proto.RegisterType((*Account)(nil), "fulfilment.Account")
	proto.RegisterType((*AccountHolder)(nil), "fulfilment.AccountHolder")
	proto.RegisterType((*Address)(nil), "fulfilment.Address")
	proto.RegisterType((*Aggregation)(nil), "fulfilment.Aggregation")
	proto.RegisterType((*Section)(nil), "fulfilment.Section")
	proto.RegisterType((*CostItem)(nil), "fulfilment.CostItem")
	proto.RegisterType((*UsageItem)(nil), "fulfilment.UsageItem")
	proto.RegisterType((*Item)(nil), "fulfilment.Item")
	proto.RegisterType((*Item_Event)(nil), "fulfilment.Item.Event")
	proto.RegisterType((*Item_Type)(nil), "fulfilment.Item.Type")
	proto.RegisterType((*InvoiceBreakdownItem)(nil), "fulfilment.InvoiceBreakdownItem")
	proto.RegisterType((*ItemisationSection)(nil), "fulfilment.ItemisationSection")
	proto.RegisterType((*ItemisationGroup)(nil), "fulfilment.ItemisationGroup")
	proto.RegisterType((*ItemisationGroupElement)(nil), "fulfilment.ItemisationGroupElement")
	proto.RegisterType((*ProductGroup)(nil), "fulfilment.ProductGroup")
	proto.RegisterType((*Product)(nil), "fulfilment.Product")
	proto.RegisterType((*BudgetPlan)(nil), "fulfilment.BudgetPlan")
	proto.RegisterType((*Total)(nil), "fulfilment.Total")
	proto.RegisterType((*Supply)(nil), "fulfilment.Supply")
	proto.RegisterType((*Tariff)(nil), "fulfilment.Tariff")
	proto.RegisterType((*Rate)(nil), "fulfilment.Rate")
	proto.RegisterType((*Usage)(nil), "fulfilment.Usage")
	proto.RegisterType((*AlternateUsage)(nil), "fulfilment.AlternateUsage")
	proto.RegisterType((*Amount)(nil), "fulfilment.Amount")
	proto.RegisterType((*Asset)(nil), "fulfilment.Asset")
	proto.RegisterType((*VAT)(nil), "fulfilment.VAT")
}

func init() { proto.RegisterFile("invoice.proto", fileDescriptor_3b1832ff34ba7c07) }

var fileDescriptor_3b1832ff34ba7c07 = []byte{
	// 1894 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x8f, 0x1c, 0x47,
	0x15, 0xdf, 0x9e, 0x99, 0x9e, 0x9e, 0x79, 0xb3, 0x1f, 0x93, 0xda, 0x75, 0xd2, 0xd9, 0x44, 0xa3,
	0xa5, 0x13, 0xec, 0x75, 0xe4, 0xd8, 0xc4, 0x41, 0x44, 0x42, 0xa0, 0xec, 0x6e, 0x76, 0x01, 0x9b,
	0x38, 0x58, 0xed, 0xc5, 0x07, 0x2e, 0xad, 0x9a, 0xee, 0x9a, 0xd9, 0x22, 0x3d, 0xd5, 0xad, 0xae,
	0xea, 0x25, 0x7b, 0xe3, 0xc2, 0x11, 0x89, 0x1b, 0x48, 0x88, 0x0b, 0x27, 0xfe, 0x80, 0xfc, 0x0d,
	0xc8, 0x42, 0x1c, 0xcc, 0x01, 0x29, 0x47, 0xbc, 0xbe, 0x20, 0x4e, 0xfe, 0x13, 0x50, 0x7d, 0xf4,
	0x4c, 0xcf, 0x4c, 0xcf, 0x87, 0x25, 0xb8, 0x75, 0xbd, 0xf7, 0xab, 0xd7, 0xaf, 0xde, 0x77, 0x15,
	0x6c, 0x51, 0x76, 0x99, 0xd0, 0x90, 0xdc, 0x4d, 0xb3, 0x44, 0x24, 0x08, 0x06, 0x79, 0x3c, 0xa0,
	0xf1, 0x88, 0x30, 0xe1, 0xfd, 0xcd, 0x06, 0xe7, 0x81, 0xe6, 0xa2, 0x6d, 0xa8, 0xd1, 0xc8, 0xb5,
	0x0e, 0xac, 0xc3, 0xb6, 0x5f, 0xa3, 0x11, 0x42, 0xd0, 0x88, 0xb0, 0x20, 0x6e, 0x4d, 0x51, 0xd4,
	0x37, 0xfa, 0x36, 0x6c, 0x1b, 0x61, 0x41, 0x4a, 0x32, 0x9a, 0x44, 0x6e, 0x5d, 0x71, 0x8b, 0x5f,
	0x3c, 0x56, 0x44, 0x09, 0x4b, 0xf1, 0x95, 0xfc, 0x43, 0x30, 0x22, 0xe2, 0x22, 0x89, 0xdc, 0x86,
	0x86, 0x19, 0xea, 0x23, 0x45, 0x44, 0x1f, 0x82, 0x83, 0xc3, 0x30, 0xc9, 0x99, 0x70, 0xed, 0x03,
	0xeb, 0xb0, 0x73, 0x7f, 0xf7, 0xee, 0x44, 0xb7, 0xbb, 0xc7, 0x9a, 0xe5, 0x17, 0x18, 0x74, 0x04,
	0x3b, 0xc5, 0xcf, 0x79, 0x3e, 0x1a, 0xe1, 0xec, 0xca, 0x6d, 0xaa, 0x6d, 0x6f, 0x4d, 0x6d, 0x1b,
	0x0e, 0x33, 0x32, 0xc4, 0x82, 0x26, 0xcc, 0x2f, 0x94, 0x7d, 0xa2, 0xe1, 0xe8, 0x11, 0xbc, 0x51,
	0x48, 0xe8, 0x67, 0x04, 0x7f, 0x19, 0x25, 0xbf, 0x62, 0xae, 0x73, 0x50, 0x3f, 0xec, 0xdc, 0x3f,
	0x28, 0xcb, 0x30, 0x26, 0x39, 0x29, 0x30, 0x0f, 0x04, 0x19, 0xf9, 0x5d, 0x3a, 0x43, 0x45, 0x9f,
	0xc3, 0x8d, 0x0b, 0x3a, 0xbc, 0x88, 0xe9, 0xf0, 0x42, 0x90, 0xa8, 0x24, 0xb2, 0xb5, 0x5c, 0xad,
	0xbd, 0xd2, 0xae, 0x89, 0xb4, 0x4f, 0x61, 0x3b, 0xcd, 0x92, 0x28, 0x0f, 0x45, 0x30, 0xcc, 0x92,
	0x3c, 0xe5, 0x6e, 0x5b, 0x69, 0xe6, 0x96, 0xc5, 0x3c, 0xd6, 0x88, 0x1f, 0x4b, 0x80, 0xbf, 0x95,
	0x96, 0x56, 0x1c, 0x1d, 0x03, 0x0a, 0x33, 0x12, 0x51, 0xc1, 0x03, 0xcc, 0xa2, 0x20, 0x22, 0x7d,
	0x2a, 0xb8, 0x0b, 0xf3, 0x96, 0x7d, 0x42, 0x42, 0xa5, 0x47, 0xd7, 0xc0, 0x8f, 0x59, 0x74, 0xaa,
	0xc0, 0xe8, 0x7b, 0x32, 0x58, 0x06, 0x49, 0x30, 0x22, 0x9c, 0xe3, 0x21, 0xe1, 0x6e, 0x47, 0xa9,
	0xf0, 0xc6, 0xd4, 0x49, 0x38, 0x27, 0xc2, 0xdf, 0x94, 0xb8, 0x47, 0x06, 0x86, 0x6e, 0x43, 0x13,
	0x4b, 0x32, 0x77, 0x37, 0x17, 0x6d, 0x30, 0x00, 0xf4, 0x26, 0x34, 0x71, 0x14, 0x25, 0x8c, 0xbb,
	0x5b, 0x07, 0xf5, 0xc3, 0xb6, 0x6f, 0x56, 0xe8, 0x08, 0x3a, 0x54, 0x90, 0x11, 0xe5, 0xca, 0x46,
	0xee, 0xb6, 0x52, 0xbb, 0x37, 0xe5, 0x95, 0x09, 0xbb, 0x38, 0x41, 0x79, 0x8b, 0xf7, 0x8f, 0x1a,
	0x38, 0x26, 0x68, 0xe6, 0x82, 0xf9, 0x08, 0xb6, 0x4d, 0x18, 0x05, 0x17, 0x49, 0x1c, 0x91, 0x4c,
	0x85, 0x75, 0xe7, 0xfe, 0xdb, 0x15, 0x11, 0xf7, 0x13, 0x05, 0xf0, 0xb7, 0x70, 0x79, 0x89, 0xde,
	0x81, 0xf6, 0x2f, 0x13, 0xca, 0x02, 0x95, 0x13, 0x3a, 0xea, 0x5b, 0x92, 0x70, 0x2a, 0xf3, 0xe2,
	0x10, 0xba, 0xe3, 0xbc, 0xc0, 0x57, 0x1a, 0xa3, 0x43, 0xbe, 0x08, 0xc1, 0xc7, 0xf8, 0x4a, 0x21,
	0x7f, 0x00, 0x3b, 0x7d, 0x1a, 0xc7, 0x94, 0x0d, 0x03, 0x1c, 0x45, 0x19, 0xe1, 0xbc, 0x32, 0xf6,
	0x35, 0xcb, 0xdf, 0x36, 0x58, 0xb3, 0x46, 0xa7, 0xb0, 0x9b, 0xe4, 0x82, 0x0b, 0xcc, 0x22, 0x29,
	0xa1, 0x8f, 0x63, 0xcc, 0x42, 0x62, 0xd2, 0xa0, 0xd2, 0xc7, 0xa8, 0x84, 0x3f, 0xd1, 0xf0, 0x92,
	0xb7, 0x9c, 0x15, 0xde, 0xf2, 0xfe, 0x6e, 0xc1, 0xd6, 0x94, 0x59, 0xd0, 0x1e, 0xd8, 0x82, 0x8a,
	0x98, 0x18, 0xe3, 0xea, 0x05, 0x7a, 0x1b, 0x5a, 0x38, 0x16, 0x01, 0xc3, 0x23, 0xe2, 0xda, 0xca,
	0xaf, 0x0e, 0x8e, 0xc5, 0x17, 0x78, 0x44, 0xd0, 0x3d, 0xd8, 0x0d, 0x93, 0x2c, 0x23, 0x3c, 0x4d,
	0x58, 0x44, 0x58, 0x48, 0x34, 0xaa, 0xa9, 0xb6, 0xa3, 0x69, 0x96, 0xda, 0xb0, 0x07, 0x36, 0x19,
	0x61, 0x1a, 0xbb, 0x8e, 0xfe, 0x83, 0x5a, 0x48, 0x6a, 0x7a, 0x91, 0x30, 0xa2, 0x92, 0xab, 0xed,
	0xeb, 0x85, 0xf4, 0xca, 0x20, 0x8f, 0x63, 0x2d, 0xb2, 0xad, 0xbd, 0x22, 0x09, 0x52, 0xd0, 0xc3,
	0x46, 0xab, 0xd6, 0xad, 0x3f, 0x6c, 0xb4, 0xea, 0xdd, 0xc6, 0xc3, 0x46, 0xab, 0xd1, 0xb5, 0xbd,
	0x87, 0xe0, 0x14, 0xa6, 0xdc, 0x87, 0x56, 0x9a, 0x70, 0x11, 0x26, 0x51, 0x71, 0x94, 0xf1, 0x1a,
	0xbd, 0x07, 0x5b, 0xc6, 0x39, 0x41, 0x4c, 0x19, 0xe1, 0x6e, 0x4d, 0x1d, 0x69, 0xd3, 0x10, 0x3f,
	0x97, 0x34, 0xef, 0x0f, 0x16, 0x74, 0x4a, 0x59, 0x8d, 0x0e, 0xa0, 0x13, 0x11, 0x1e, 0x66, 0x34,
	0x55, 0x01, 0xac, 0x65, 0x96, 0x49, 0xe8, 0x03, 0xb0, 0x65, 0xbc, 0x6a, 0x71, 0x9d, 0xfb, 0x7b,
	0x65, 0xb3, 0x7f, 0x96, 0x70, 0xa1, 0xca, 0x8c, 0x86, 0xa0, 0x5b, 0x60, 0x8b, 0x44, 0xe0, 0x58,
	0x85, 0xda, 0x8c, 0x8b, 0xce, 0x25, 0xc3, 0xd7, 0x7c, 0x59, 0xa6, 0xc5, 0x55, 0x5a, 0x84, 0x9b,
	0xfa, 0xf6, 0xfe, 0x63, 0x81, 0x63, 0x02, 0x60, 0x0d, 0xb5, 0x3e, 0x02, 0xa7, 0xa8, 0xa7, 0x5a,
	0xb1, 0x85, 0x85, 0xab, 0xc0, 0x95, 0x22, 0xa8, 0xbe, 0x2a, 0xdf, 0xe7, 0x4a, 0x4a, 0x63, 0xbd,
	0x92, 0x32, 0x36, 0x80, 0xbd, 0xdc, 0x00, 0xde, 0x9f, 0x2d, 0x68, 0x15, 0xd6, 0x5b, 0xe3, 0xb4,
	0xd5, 0x6d, 0xad, 0x11, 0x26, 0x5c, 0x2c, 0xb6, 0xb5, 0x62, 0x57, 0x99, 0x5a, 0x6e, 0xa5, 0x61,
	0xc2, 0xaa, 0xb4, 0xd4, 0xa7, 0x52, 0x6c, 0xef, 0x29, 0xb4, 0x7f, 0x2e, 0xcf, 0xb5, 0xa6, 0x92,
	0xb7, 0xc0, 0xce, 0x25, 0xdc, 0x54, 0xa9, 0x29, 0xb1, 0x4a, 0x8e, 0xaf, 0xf9, 0xde, 0x3f, 0x1b,
	0xd0, 0x58, 0x53, 0xe6, 0x1d, 0xb0, 0xb9, 0xc0, 0x99, 0x30, 0x32, 0xdf, 0x9c, 0x2d, 0xad, 0x77,
	0xcf, 0x2e, 0x09, 0x13, 0xbe, 0x06, 0xa1, 0x43, 0xa8, 0x13, 0x16, 0x19, 0x8b, 0x2c, 0xc2, 0x4a,
	0xc8, 0x44, 0xd7, 0xc6, 0x72, 0x5d, 0xd1, 0x27, 0xd0, 0x96, 0x35, 0x42, 0x83, 0xb5, 0xbd, 0xf6,
	0xa7, 0xec, 0x15, 0x0b, 0x92, 0x31, 0x2c, 0x88, 0xde, 0x25, 0x0b, 0x8a, 0xfa, 0x42, 0x37, 0x8d,
	0x7b, 0x74, 0x99, 0x43, 0x53, 0x7b, 0x46, 0x6a, 0x46, 0xd0, 0xfe, 0x71, 0xc1, 0x49, 0x33, 0x92,
	0x62, 0x1a, 0xa9, 0xd2, 0xd1, 0xf2, 0x8b, 0x25, 0xba, 0x6d, 0x3c, 0xa7, 0x1b, 0xf3, 0x8d, 0xb9,
	0xe3, 0x9c, 0x5f, 0xa5, 0xc4, 0x38, 0xf4, 0x7d, 0x68, 0x64, 0x32, 0x3e, 0xda, 0x0a, 0xda, 0x2d,
	0x43, 0x7d, 0x2c, 0x88, 0xaf, 0xb8, 0xd2, 0xdc, 0xa7, 0x84, 0x0b, 0xca, 0x74, 0xb7, 0x02, 0x6d,
	0xee, 0x12, 0x69, 0x7f, 0x00, 0xb6, 0x32, 0xd2, 0xff, 0xd0, 0xdb, 0xe3, 0xd8, 0xad, 0x4f, 0x62,
	0x77, 0xff, 0x1c, 0x1a, 0x52, 0x7b, 0x59, 0xcf, 0x64, 0xe5, 0x90, 0xdf, 0x45, 0x3d, 0x2b, 0xd6,
	0xe8, 0x3b, 0xb0, 0xab, 0x04, 0x7c, 0x16, 0x63, 0xce, 0xe9, 0x80, 0x86, 0x5a, 0x6b, 0x9d, 0x02,
	0x55, 0x2c, 0xef, 0x4f, 0x16, 0xec, 0x55, 0x4d, 0x41, 0xeb, 0x25, 0x98, 0xb2, 0x75, 0xad, 0x94,
	0x25, 0x37, 0xa7, 0x12, 0x6c, 0xb1, 0x07, 0x6f, 0x81, 0xad, 0xca, 0x46, 0x55, 0x2c, 0xe9, 0x74,
	0xd2, 0x7c, 0xef, 0xf7, 0x16, 0xa0, 0xf9, 0x79, 0x60, 0x0d, 0xed, 0x26, 0x95, 0xab, 0xb6, 0xaa,
	0x72, 0x7d, 0x17, 0x9a, 0x66, 0x10, 0xd3, 0x45, 0xee, 0xdd, 0x05, 0xc3, 0x88, 0x1e, 0xc6, 0x0c,
	0xd6, 0xfb, 0xda, 0x82, 0xee, 0x2c, 0x73, 0x6c, 0x13, 0xab, 0x64, 0x93, 0x19, 0x5d, 0x6b, 0xcb,
	0x74, 0x5d, 0x59, 0x65, 0x3f, 0x85, 0x16, 0x89, 0x89, 0x64, 0x14, 0x05, 0xf6, 0xbd, 0x65, 0xda,
	0x9e, 0x69, 0xac, 0x3f, 0xde, 0xe4, 0xfd, 0xd6, 0x82, 0xb7, 0x16, 0xa0, 0x2a, 0xb5, 0xdf, 0x03,
	0x3b, 0xc6, 0x7d, 0x12, 0x1b, 0xbd, 0xf5, 0x62, 0xf6, 0x4c, 0xf5, 0xf9, 0x33, 0xdd, 0x2c, 0x7a,
	0xa0, 0xd6, 0xb2, 0x3b, 0xab, 0xa5, 0xe9, 0x7f, 0xde, 0xb3, 0x3a, 0x6c, 0x96, 0x87, 0xdd, 0xff,
	0xbf, 0x09, 0xef, 0x41, 0xcb, 0xcc, 0xd3, 0x85, 0x72, 0xbb, 0x15, 0x93, 0xb7, 0x3f, 0x06, 0xad,
	0xdd, 0xa1, 0xe6, 0x5b, 0x60, 0x73, 0xbd, 0x16, 0x58, 0x6a, 0xcc, 0xce, 0x9a, 0x8d, 0xf9, 0xac,
	0xf2, 0x0e, 0xb0, 0xe2, 0x3e, 0x32, 0x7f, 0x0f, 0xf8, 0x29, 0xdc, 0x48, 0x06, 0x03, 0x4e, 0x44,
	0x20, 0x92, 0xa0, 0x34, 0x41, 0x9a, 0xaa, 0xb8, 0x50, 0xd2, 0xae, 0xde, 0x75, 0x9e, 0xfc, 0x6c,
	0xb2, 0xc7, 0xfb, 0xda, 0x06, 0xc7, 0x58, 0x0f, 0x7d, 0x0b, 0x36, 0x8b, 0x4b, 0x4e, 0xc9, 0x9b,
	0x1d, 0x43, 0x3b, 0x5f, 0xcf, 0xa9, 0xe3, 0xd8, 0xab, 0x97, 0x63, 0xef, 0x1d, 0x68, 0x33, 0x1a,
	0x7e, 0xa9, 0x47, 0x41, 0xdd, 0xa2, 0x5b, 0x92, 0xa0, 0x66, 0x4a, 0x79, 0xeb, 0x08, 0x05, 0xbd,
	0xd4, 0x8d, 0xa7, 0xe5, 0x9b, 0x15, 0xba, 0x0d, 0x5d, 0x41, 0xb2, 0x91, 0x29, 0xda, 0x7a, 0x70,
	0xd7, 0x93, 0xe9, 0x4e, 0x89, 0xae, 0x26, 0xf7, 0x71, 0xe4, 0x3a, 0x4b, 0x23, 0x17, 0x7d, 0x00,
	0x4d, 0x81, 0x33, 0x3a, 0x18, 0x18, 0xb3, 0x4f, 0x55, 0xbb, 0x73, 0xc5, 0xf1, 0x0d, 0x42, 0x62,
	0x79, 0x9e, 0xa6, 0xf1, 0x95, 0x31, 0xec, 0x14, 0xf6, 0x89, 0xe2, 0xf8, 0x06, 0x81, 0x3e, 0x86,
	0xf6, 0x05, 0xe5, 0x22, 0x19, 0x66, 0x78, 0xe4, 0x82, 0xd2, 0xe1, 0xc6, 0x5c, 0xa7, 0x50, 0x8a,
	0x4c, 0x70, 0xe8, 0x43, 0xb0, 0x65, 0x61, 0x95, 0x17, 0xb9, 0xa5, 0x8e, 0xd3, 0xa8, 0x05, 0xe1,
	0xb3, 0xf9, 0xba, 0xe1, 0xf3, 0x09, 0x74, 0xfa, 0x79, 0x34, 0x24, 0x22, 0x48, 0x63, 0xcc, 0xdc,
	0xad, 0xf9, 0x21, 0xe2, 0x44, 0xb1, 0x1f, 0xc7, 0x98, 0xf9, 0xd0, 0x1f, 0x7f, 0x4f, 0x52, 0x6a,
	0xfb, 0x75, 0x53, 0x6a, 0xe7, 0x75, 0x2f, 0xaa, 0xdd, 0x55, 0x57, 0x9f, 0xbf, 0xd6, 0x00, 0x4e,
	0x2a, 0x54, 0xb3, 0x56, 0xa8, 0x76, 0x07, 0x9c, 0xe2, 0x5e, 0x56, 0x5b, 0xd8, 0xee, 0x0a, 0x08,
	0xfa, 0x21, 0x74, 0xd3, 0x8c, 0x5c, 0xd2, 0x24, 0xe7, 0xe3, 0xeb, 0xdc, 0xe2, 0x2e, 0xb9, 0x53,
	0x60, 0x8b, 0xab, 0xdc, 0x3d, 0xd8, 0x35, 0xbb, 0x82, 0x72, 0xd2, 0xe8, 0xf0, 0x47, 0x86, 0x75,
	0x5a, 0xca, 0x9d, 0xd2, 0x06, 0xf2, 0x95, 0xf4, 0x8e, 0x1e, 0x05, 0xec, 0xa9, 0x0d, 0x67, 0x13,
	0x0e, 0x3a, 0x82, 0x77, 0x67, 0x15, 0x9c, 0xfa, 0x95, 0xce, 0x96, 0xfd, 0x19, 0xc5, 0x4a, 0xbf,
	0xf4, 0x7e, 0x63, 0x81, 0xad, 0x2c, 0x84, 0xde, 0x87, 0x3a, 0x23, 0xc2, 0x58, 0xb0, 0xea, 0x7c,
	0x92, 0x8d, 0xee, 0x40, 0xfb, 0x12, 0x8b, 0xa0, 0x7c, 0x55, 0xda, 0x29, 0x63, 0x9f, 0x1e, 0x9f,
	0xfb, 0xad, 0x4b, 0xac, 0x06, 0x7e, 0x8e, 0x0e, 0xc1, 0x1e, 0x66, 0x09, 0xe7, 0x4b, 0xac, 0xa6,
	0x01, 0xde, 0x1f, 0x2d, 0x68, 0xea, 0x9c, 0x92, 0xb5, 0x42, 0x67, 0x55, 0x30, 0x7e, 0x25, 0x68,
	0x69, 0xc2, 0x83, 0x48, 0xde, 0xfe, 0x38, 0xc9, 0x28, 0x8e, 0x03, 0x96, 0x8f, 0xfa, 0xe6, 0xa9,
	0xa0, 0xed, 0x6f, 0x6a, 0xe2, 0x17, 0x8a, 0xa6, 0xaa, 0x14, 0xe5, 0x22, 0xa3, 0xfd, 0x5c, 0x24,
	0x99, 0xea, 0x2e, 0xb2, 0x4a, 0x4d, 0x48, 0xea, 0x75, 0x6b, 0xf5, 0x0d, 0xbf, 0xc0, 0x78, 0xcf,
	0x2c, 0x68, 0xea, 0xea, 0x20, 0x5b, 0x9d, 0x2a, 0x62, 0xa6, 0xd5, 0xc9, 0xef, 0x8a, 0x27, 0xb5,
	0x5a, 0xf5, 0x93, 0x5a, 0x8b, 0x7c, 0x45, 0x45, 0x30, 0x20, 0xcb, 0xc2, 0xc8, 0x91, 0x98, 0x1f,
	0x11, 0x75, 0x6d, 0x27, 0x32, 0xcf, 0x27, 0xef, 0x15, 0x0e, 0x61, 0x91, 0x2a, 0x77, 0x93, 0x4c,
	0xb1, 0x57, 0x75, 0x4e, 0xfd, 0xd8, 0xd2, 0x2c, 0x1e, 0x5b, 0xbc, 0x13, 0x68, 0xf8, 0xba, 0x62,
	0xea, 0xa9, 0xcf, 0x5a, 0x31, 0xf5, 0x21, 0x68, 0xe4, 0x8c, 0x8a, 0x62, 0x62, 0x94, 0xdf, 0xde,
	0x47, 0x60, 0xeb, 0xe1, 0x7f, 0x0f, 0xec, 0x4b, 0x1c, 0xe7, 0xe3, 0xf7, 0x06, 0xb5, 0xa8, 0xdc,
	0xe2, 0xc3, 0xf6, 0xf4, 0x15, 0x62, 0xfd, 0xbd, 0xb2, 0x3f, 0x0c, 0x70, 0xa8, 0x3d, 0x29, 0xa9,
	0x66, 0xe5, 0x7d, 0x1f, 0x9a, 0x5a, 0xd5, 0x05, 0xb2, 0xf6, 0xa1, 0x15, 0xe6, 0x59, 0x46, 0x58,
	0x78, 0x65, 0xe4, 0x8d, 0xd7, 0x1e, 0x05, 0x5b, 0xd9, 0x69, 0x8d, 0xa9, 0xd4, 0x05, 0x27, 0x4c,
	0x98, 0x20, 0xac, 0xd0, 0xaa, 0x58, 0xa2, 0x2e, 0xd4, 0xf3, 0xac, 0xe8, 0x74, 0xf2, 0xb3, 0xf2,
	0xc2, 0x7f, 0x06, 0xf5, 0xa7, 0xc7, 0xe7, 0x92, 0xd5, 0xc7, 0xac, 0x88, 0x68, 0xf5, 0x2d, 0x5b,
	0x0c, 0x56, 0x27, 0x58, 0x52, 0x8d, 0x0c, 0xe2, 0xe4, 0xe8, 0xf9, 0x8b, 0xde, 0xc6, 0x37, 0x2f,
	0x7a, 0x1b, 0xaf, 0x5e, 0xf4, 0xac, 0x5f, 0x5f, 0xf7, 0xac, 0xbf, 0x5c, 0xf7, 0xac, 0x67, 0xd7,
	0x3d, 0xeb, 0xf9, 0x75, 0xcf, 0xfa, 0xd7, 0x75, 0xcf, 0xfa, 0xf7, 0x75, 0x6f, 0xe3, 0xd5, 0x75,
	0xcf, 0xfa, 0xdd, 0xcb, 0xde, 0xc6, 0xf3, 0x97, 0xbd, 0x8d, 0x6f, 0x5e, 0xf6, 0x36, 0x7e, 0x51,
	0x7a, 0x50, 0xee, 0x37, 0xd5, 0x1b, 0xf3, 0xc7, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x53, 0x22,
	0x91, 0x1f, 0x74, 0x16, 0x00, 0x00,
}

func (this *Invoice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Invoice)
	if !ok {
		that2, ok := that.(Invoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	if this.InvoicePeriod != that1.InvoicePeriod {
		return false
	}
	if this.PaymentMethod != that1.PaymentMethod {
		return false
	}
	if !this.Account.Equal(that1.Account) {
		return false
	}
	if !this.InvoiceSummary.Equal(that1.InvoiceSummary) {
		return false
	}
	if len(this.InvoiceBreakdown) != len(that1.InvoiceBreakdown) {
		return false
	}
	for i := range this.InvoiceBreakdown {
		if !this.InvoiceBreakdown[i].Equal(that1.InvoiceBreakdown[i]) {
			return false
		}
	}
	if !this.HighlightedBreakdown.Equal(that1.HighlightedBreakdown) {
		return false
	}
	if len(this.ProductGroups) != len(that1.ProductGroups) {
		return false
	}
	for i := range this.ProductGroups {
		if !this.ProductGroups[i].Equal(that1.ProductGroups[i]) {
			return false
		}
	}
	if !this.CreditsAndDebits.Equal(that1.CreditsAndDebits) {
		return false
	}
	if len(this.InfoMessages) != len(that1.InfoMessages) {
		return false
	}
	for i := range this.InfoMessages {
		if !this.InfoMessages[i].Equal(that1.InfoMessages[i]) {
			return false
		}
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	if len(this.Addons) != len(that1.Addons) {
		return false
	}
	for i := range this.Addons {
		if this.Addons[i] != that1.Addons[i] {
			return false
		}
	}
	if !this.Itemisation.Equal(that1.Itemisation) {
		return false
	}
	return true
}
func (this *Account) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Account)
	if !ok {
		that2, ok := that.(Account)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.AccountHolder.Equal(that1.AccountHolder) {
		return false
	}
	if this.JoinDate != that1.JoinDate {
		return false
	}
	if this.InvoicePayDate != that1.InvoicePayDate {
		return false
	}
	if !this.BillingAddress.Equal(that1.BillingAddress) {
		return false
	}
	if !this.OutstandingBalance.Equal(that1.OutstandingBalance) {
		return false
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	return true
}
func (this *AccountHolder) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountHolder)
	if !ok {
		that2, ok := that.(AccountHolder)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if len(this.AltName) != len(that1.AltName) {
		return false
	}
	for i := range this.AltName {
		if this.AltName[i] != that1.AltName[i] {
			return false
		}
	}
	if this.CorrespondenceName != that1.CorrespondenceName {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.Phone != that1.Phone {
		return false
	}
	if this.FullName != that1.FullName {
		return false
	}
	return true
}
func (this *Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Address)
	if !ok {
		that2, ok := that.(Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Postcode != that1.Postcode {
		return false
	}
	if len(this.AddressLines) != len(that1.AddressLines) {
		return false
	}
	for i := range this.AddressLines {
		if this.AddressLines[i] != that1.AddressLines[i] {
			return false
		}
	}
	return true
}
func (this *Aggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Aggregation)
	if !ok {
		that2, ok := that.(Aggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	if !this.Total.Equal(that1.Total) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Section) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Section)
	if !ok {
		that2, ok := that.(Section)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Summary) != len(that1.Summary) {
		return false
	}
	for i := range this.Summary {
		if !this.Summary[i].Equal(that1.Summary[i]) {
			return false
		}
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	if len(this.InfoMessages) != len(that1.InfoMessages) {
		return false
	}
	for i := range this.InfoMessages {
		if !this.InfoMessages[i].Equal(that1.InfoMessages[i]) {
			return false
		}
	}
	if !this.Total.Equal(that1.Total) {
		return false
	}
	return true
}
func (this *CostItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CostItem)
	if !ok {
		that2, ok := that.(CostItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	if !this.Cost.Equal(that1.Cost) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Icon.Equal(that1.Icon) {
		return false
	}
	return true
}
func (this *UsageItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UsageItem)
	if !ok {
		that2, ok := that.(UsageItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.Usage.Equal(that1.Usage) {
		return false
	}
	return true
}
func (this *Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Item)
	if !ok {
		that2, ok := that.(Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.Start.Equal(that1.Start) {
		return false
	}
	if !this.End.Equal(that1.End) {
		return false
	}
	if !this.Usage.Equal(that1.Usage) {
		return false
	}
	if !this.AltUsage.Equal(that1.AltUsage) {
		return false
	}
	if !this.Cost.Equal(that1.Cost) {
		return false
	}
	if this.Prepaid != that1.Prepaid {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	if !this.Rate.Equal(that1.Rate) {
		return false
	}
	if this.Destination != that1.Destination {
		return false
	}
	return true
}
func (this *Item_Event) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Item_Event)
	if !ok {
		that2, ok := that.(Item_Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.Usage.Equal(that1.Usage) {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *Item_Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Item_Type)
	if !ok {
		that2, ok := that.(Item_Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ItemType != that1.ItemType {
		return false
	}
	if this.UsageClassification != that1.UsageClassification {
		return false
	}
	return true
}
func (this *InvoiceBreakdownItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InvoiceBreakdownItem)
	if !ok {
		that2, ok := that.(InvoiceBreakdownItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Cost.Equal(that1.Cost) {
		return false
	}
	if !this.Asset.Equal(that1.Asset) {
		return false
	}
	return true
}
func (this *ItemisationSection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ItemisationSection)
	if !ok {
		that2, ok := that.(ItemisationSection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	if len(this.Groups) != len(that1.Groups) {
		return false
	}
	for i := range this.Groups {
		if !this.Groups[i].Equal(that1.Groups[i]) {
			return false
		}
	}
	return true
}
func (this *ItemisationGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ItemisationGroup)
	if !ok {
		that2, ok := that.(ItemisationGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	if len(this.Elements) != len(that1.Elements) {
		return false
	}
	for i := range this.Elements {
		if !this.Elements[i].Equal(that1.Elements[i]) {
			return false
		}
	}
	return true
}
func (this *ItemisationGroupElement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ItemisationGroupElement)
	if !ok {
		that2, ok := that.(ItemisationGroupElement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ProductGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductGroup)
	if !ok {
		that2, ok := that.(ProductGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	if len(this.Products) != len(that1.Products) {
		return false
	}
	for i := range this.Products {
		if !this.Products[i].Equal(that1.Products[i]) {
			return false
		}
	}
	if !this.Total.Equal(that1.Total) {
		return false
	}
	if len(this.InfoMessages) != len(that1.InfoMessages) {
		return false
	}
	for i := range this.InfoMessages {
		if !this.InfoMessages[i].Equal(that1.InfoMessages[i]) {
			return false
		}
	}
	if len(this.Summary) != len(that1.Summary) {
		return false
	}
	for i := range this.Summary {
		if !this.Summary[i].Equal(that1.Summary[i]) {
			return false
		}
	}
	if !this.CreditsAndDebits.Equal(that1.CreditsAndDebits) {
		return false
	}
	if !this.OffsetToOutstanding.Equal(that1.OffsetToOutstanding) {
		return false
	}
	return true
}
func (this *Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Product)
	if !ok {
		that2, ok := that.(Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProductType != that1.ProductType {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.NickName != that1.NickName {
		return false
	}
	if this.Active != that1.Active {
		return false
	}
	if this.TerminationDate != that1.TerminationDate {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	if !this.Tariff.Equal(that1.Tariff) {
		return false
	}
	if !this.Supply.Equal(that1.Supply) {
		return false
	}
	if len(this.Histogram) != len(that1.Histogram) {
		return false
	}
	for i := range this.Histogram {
		if !this.Histogram[i].Equal(that1.Histogram[i]) {
			return false
		}
	}
	if !this.Costs.Equal(that1.Costs) {
		return false
	}
	if !this.CreditsAndDebits.Equal(that1.CreditsAndDebits) {
		return false
	}
	if !this.BudgetPlan.Equal(that1.BudgetPlan) {
		return false
	}
	if !this.Total.Equal(that1.Total) {
		return false
	}
	if len(this.InfoMessages) != len(that1.InfoMessages) {
		return false
	}
	for i := range this.InfoMessages {
		if !this.InfoMessages[i].Equal(that1.InfoMessages[i]) {
			return false
		}
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	return true
}
func (this *BudgetPlan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BudgetPlan)
	if !ok {
		that2, ok := that.(BudgetPlan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Total.Equal(that1.Total) {
		return false
	}
	if !this.Balance.Equal(that1.Balance) {
		return false
	}
	if !this.PreviousBalance.Equal(that1.PreviousBalance) {
		return false
	}
	if this.BalanceDescription != that1.BalanceDescription {
		return false
	}
	if this.BalanceExplanation != that1.BalanceExplanation {
		return false
	}
	if this.PreviousBalanceDescription != that1.PreviousBalanceDescription {
		return false
	}
	return true
}
func (this *Total) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Total)
	if !ok {
		that2, ok := that.(Total)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Net.Equal(that1.Net) {
		return false
	}
	if len(this.VatItems) != len(that1.VatItems) {
		return false
	}
	for i := range this.VatItems {
		if !this.VatItems[i].Equal(that1.VatItems[i]) {
			return false
		}
	}
	if !this.Gross.Equal(that1.Gross) {
		return false
	}
	return true
}
func (this *Supply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Supply)
	if !ok {
		that2, ok := that.(Supply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SupplyId != that1.SupplyId {
		return false
	}
	if this.SerialNumber != that1.SerialNumber {
		return false
	}
	if len(this.Distributor) != len(that1.Distributor) {
		return false
	}
	for i := range this.Distributor {
		if this.Distributor[i] != that1.Distributor[i] {
			return false
		}
	}
	if !this.Address.Equal(that1.Address) {
		return false
	}
	return true
}
func (this *Tariff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tariff)
	if !ok {
		that2, ok := that.(Tariff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.PaymentMethod != that1.PaymentMethod {
		return false
	}
	if !this.ExitFee.Equal(that1.ExitFee) {
		return false
	}
	if this.EndDate != that1.EndDate {
		return false
	}
	if len(this.Assets) != len(that1.Assets) {
		return false
	}
	for i := range this.Assets {
		if !this.Assets[i].Equal(that1.Assets[i]) {
			return false
		}
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *Rate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rate)
	if !ok {
		that2, ok := that.(Rate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cost.Equal(that1.Cost) {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	return true
}
func (this *Usage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Usage)
	if !ok {
		that2, ok := that.(Usage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	return true
}
func (this *AlternateUsage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AlternateUsage)
	if !ok {
		that2, ok := that.(AlternateUsage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	if this.Factor != that1.Factor {
		return false
	}
	return true
}
func (this *Amount) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Amount)
	if !ok {
		that2, ok := that.(Amount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Currency != that1.Currency {
		return false
	}
	return true
}
func (this *Asset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Asset)
	if !ok {
		that2, ok := that.(Asset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Content != that1.Content {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *VAT) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VAT)
	if !ok {
		that2, ok := that.(VAT)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Band != that1.Band {
		return false
	}
	if !this.Amount.Equal(that1.Amount) {
		return false
	}
	return true
}
func (this *Invoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&fulfilment.Invoice{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "InvoicePeriod: "+fmt.Sprintf("%#v", this.InvoicePeriod)+",\n")
	s = append(s, "PaymentMethod: "+fmt.Sprintf("%#v", this.PaymentMethod)+",\n")
	if this.Account != nil {
		s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	}
	if this.InvoiceSummary != nil {
		s = append(s, "InvoiceSummary: "+fmt.Sprintf("%#v", this.InvoiceSummary)+",\n")
	}
	if this.InvoiceBreakdown != nil {
		s = append(s, "InvoiceBreakdown: "+fmt.Sprintf("%#v", this.InvoiceBreakdown)+",\n")
	}
	if this.HighlightedBreakdown != nil {
		s = append(s, "HighlightedBreakdown: "+fmt.Sprintf("%#v", this.HighlightedBreakdown)+",\n")
	}
	if this.ProductGroups != nil {
		s = append(s, "ProductGroups: "+fmt.Sprintf("%#v", this.ProductGroups)+",\n")
	}
	if this.CreditsAndDebits != nil {
		s = append(s, "CreditsAndDebits: "+fmt.Sprintf("%#v", this.CreditsAndDebits)+",\n")
	}
	if this.InfoMessages != nil {
		s = append(s, "InfoMessages: "+fmt.Sprintf("%#v", this.InfoMessages)+",\n")
	}
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	s = append(s, "Addons: "+fmt.Sprintf("%#v", this.Addons)+",\n")
	if this.Itemisation != nil {
		s = append(s, "Itemisation: "+fmt.Sprintf("%#v", this.Itemisation)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Account) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&fulfilment.Account{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.AccountHolder != nil {
		s = append(s, "AccountHolder: "+fmt.Sprintf("%#v", this.AccountHolder)+",\n")
	}
	s = append(s, "JoinDate: "+fmt.Sprintf("%#v", this.JoinDate)+",\n")
	s = append(s, "InvoicePayDate: "+fmt.Sprintf("%#v", this.InvoicePayDate)+",\n")
	if this.BillingAddress != nil {
		s = append(s, "BillingAddress: "+fmt.Sprintf("%#v", this.BillingAddress)+",\n")
	}
	if this.OutstandingBalance != nil {
		s = append(s, "OutstandingBalance: "+fmt.Sprintf("%#v", this.OutstandingBalance)+",\n")
	}
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccountHolder) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&fulfilment.AccountHolder{")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "AltName: "+fmt.Sprintf("%#v", this.AltName)+",\n")
	s = append(s, "CorrespondenceName: "+fmt.Sprintf("%#v", this.CorrespondenceName)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "Phone: "+fmt.Sprintf("%#v", this.Phone)+",\n")
	s = append(s, "FullName: "+fmt.Sprintf("%#v", this.FullName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fulfilment.Address{")
	s = append(s, "Postcode: "+fmt.Sprintf("%#v", this.Postcode)+",\n")
	s = append(s, "AddressLines: "+fmt.Sprintf("%#v", this.AddressLines)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Aggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fulfilment.Aggregation{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	if this.Total != nil {
		s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Section) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&fulfilment.Section{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.Summary != nil {
		s = append(s, "Summary: "+fmt.Sprintf("%#v", this.Summary)+",\n")
	}
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	if this.InfoMessages != nil {
		s = append(s, "InfoMessages: "+fmt.Sprintf("%#v", this.InfoMessages)+",\n")
	}
	if this.Total != nil {
		s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CostItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&fulfilment.CostItem{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	if this.Cost != nil {
		s = append(s, "Cost: "+fmt.Sprintf("%#v", this.Cost)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Icon != nil {
		s = append(s, "Icon: "+fmt.Sprintf("%#v", this.Icon)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UsageItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fulfilment.UsageItem{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.Usage != nil {
		s = append(s, "Usage: "+fmt.Sprintf("%#v", this.Usage)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&fulfilment.Item{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.Start != nil {
		s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	}
	if this.End != nil {
		s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	}
	if this.Usage != nil {
		s = append(s, "Usage: "+fmt.Sprintf("%#v", this.Usage)+",\n")
	}
	if this.AltUsage != nil {
		s = append(s, "AltUsage: "+fmt.Sprintf("%#v", this.AltUsage)+",\n")
	}
	if this.Cost != nil {
		s = append(s, "Cost: "+fmt.Sprintf("%#v", this.Cost)+",\n")
	}
	s = append(s, "Prepaid: "+fmt.Sprintf("%#v", this.Prepaid)+",\n")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	if this.Rate != nil {
		s = append(s, "Rate: "+fmt.Sprintf("%#v", this.Rate)+",\n")
	}
	s = append(s, "Destination: "+fmt.Sprintf("%#v", this.Destination)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Item_Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fulfilment.Item_Event{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.Usage != nil {
		s = append(s, "Usage: "+fmt.Sprintf("%#v", this.Usage)+",\n")
	}
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Item_Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fulfilment.Item_Type{")
	s = append(s, "ItemType: "+fmt.Sprintf("%#v", this.ItemType)+",\n")
	s = append(s, "UsageClassification: "+fmt.Sprintf("%#v", this.UsageClassification)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InvoiceBreakdownItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fulfilment.InvoiceBreakdownItem{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Cost != nil {
		s = append(s, "Cost: "+fmt.Sprintf("%#v", this.Cost)+",\n")
	}
	if this.Asset != nil {
		s = append(s, "Asset: "+fmt.Sprintf("%#v", this.Asset)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ItemisationSection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fulfilment.ItemisationSection{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	if this.Groups != nil {
		s = append(s, "Groups: "+fmt.Sprintf("%#v", this.Groups)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ItemisationGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fulfilment.ItemisationGroup{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	if this.Elements != nil {
		s = append(s, "Elements: "+fmt.Sprintf("%#v", this.Elements)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ItemisationGroupElement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fulfilment.ItemisationGroupElement{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&fulfilment.ProductGroup{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	if this.Products != nil {
		s = append(s, "Products: "+fmt.Sprintf("%#v", this.Products)+",\n")
	}
	if this.Total != nil {
		s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	}
	if this.InfoMessages != nil {
		s = append(s, "InfoMessages: "+fmt.Sprintf("%#v", this.InfoMessages)+",\n")
	}
	if this.Summary != nil {
		s = append(s, "Summary: "+fmt.Sprintf("%#v", this.Summary)+",\n")
	}
	if this.CreditsAndDebits != nil {
		s = append(s, "CreditsAndDebits: "+fmt.Sprintf("%#v", this.CreditsAndDebits)+",\n")
	}
	if this.OffsetToOutstanding != nil {
		s = append(s, "OffsetToOutstanding: "+fmt.Sprintf("%#v", this.OffsetToOutstanding)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&fulfilment.Product{")
	s = append(s, "ProductType: "+fmt.Sprintf("%#v", this.ProductType)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "NickName: "+fmt.Sprintf("%#v", this.NickName)+",\n")
	s = append(s, "Active: "+fmt.Sprintf("%#v", this.Active)+",\n")
	s = append(s, "TerminationDate: "+fmt.Sprintf("%#v", this.TerminationDate)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	if this.Tariff != nil {
		s = append(s, "Tariff: "+fmt.Sprintf("%#v", this.Tariff)+",\n")
	}
	if this.Supply != nil {
		s = append(s, "Supply: "+fmt.Sprintf("%#v", this.Supply)+",\n")
	}
	if this.Histogram != nil {
		s = append(s, "Histogram: "+fmt.Sprintf("%#v", this.Histogram)+",\n")
	}
	if this.Costs != nil {
		s = append(s, "Costs: "+fmt.Sprintf("%#v", this.Costs)+",\n")
	}
	if this.CreditsAndDebits != nil {
		s = append(s, "CreditsAndDebits: "+fmt.Sprintf("%#v", this.CreditsAndDebits)+",\n")
	}
	if this.BudgetPlan != nil {
		s = append(s, "BudgetPlan: "+fmt.Sprintf("%#v", this.BudgetPlan)+",\n")
	}
	if this.Total != nil {
		s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	}
	if this.InfoMessages != nil {
		s = append(s, "InfoMessages: "+fmt.Sprintf("%#v", this.InfoMessages)+",\n")
	}
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BudgetPlan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&fulfilment.BudgetPlan{")
	if this.Total != nil {
		s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	}
	if this.Balance != nil {
		s = append(s, "Balance: "+fmt.Sprintf("%#v", this.Balance)+",\n")
	}
	if this.PreviousBalance != nil {
		s = append(s, "PreviousBalance: "+fmt.Sprintf("%#v", this.PreviousBalance)+",\n")
	}
	s = append(s, "BalanceDescription: "+fmt.Sprintf("%#v", this.BalanceDescription)+",\n")
	s = append(s, "BalanceExplanation: "+fmt.Sprintf("%#v", this.BalanceExplanation)+",\n")
	s = append(s, "PreviousBalanceDescription: "+fmt.Sprintf("%#v", this.PreviousBalanceDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Total) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fulfilment.Total{")
	if this.Net != nil {
		s = append(s, "Net: "+fmt.Sprintf("%#v", this.Net)+",\n")
	}
	if this.VatItems != nil {
		s = append(s, "VatItems: "+fmt.Sprintf("%#v", this.VatItems)+",\n")
	}
	if this.Gross != nil {
		s = append(s, "Gross: "+fmt.Sprintf("%#v", this.Gross)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Supply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fulfilment.Supply{")
	s = append(s, "SupplyId: "+fmt.Sprintf("%#v", this.SupplyId)+",\n")
	s = append(s, "SerialNumber: "+fmt.Sprintf("%#v", this.SerialNumber)+",\n")
	s = append(s, "Distributor: "+fmt.Sprintf("%#v", this.Distributor)+",\n")
	if this.Address != nil {
		s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Tariff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&fulfilment.Tariff{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "PaymentMethod: "+fmt.Sprintf("%#v", this.PaymentMethod)+",\n")
	if this.ExitFee != nil {
		s = append(s, "ExitFee: "+fmt.Sprintf("%#v", this.ExitFee)+",\n")
	}
	s = append(s, "EndDate: "+fmt.Sprintf("%#v", this.EndDate)+",\n")
	if this.Assets != nil {
		s = append(s, "Assets: "+fmt.Sprintf("%#v", this.Assets)+",\n")
	}
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Rate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fulfilment.Rate{")
	if this.Cost != nil {
		s = append(s, "Cost: "+fmt.Sprintf("%#v", this.Cost)+",\n")
	}
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Usage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fulfilment.Usage{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AlternateUsage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&fulfilment.AlternateUsage{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	s = append(s, "Factor: "+fmt.Sprintf("%#v", this.Factor)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Amount) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fulfilment.Amount{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Currency: "+fmt.Sprintf("%#v", this.Currency)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Asset) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&fulfilment.Asset{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Content: "+fmt.Sprintf("%#v", this.Content)+",\n")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VAT) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&fulfilment.VAT{")
	s = append(s, "Band: "+fmt.Sprintf("%#v", this.Band)+",\n")
	if this.Amount != nil {
		s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringInvoice(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Invoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Invoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Invoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Itemisation != nil {
		{
			size, err := m.Itemisation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.Addons) > 0 {
		for iNdEx := len(m.Addons) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addons[iNdEx])
			copy(dAtA[i:], m.Addons[iNdEx])
			i = encodeVarintInvoice(dAtA, i, uint64(len(m.Addons[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.InfoMessages) > 0 {
		for iNdEx := len(m.InfoMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InfoMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.CreditsAndDebits != nil {
		{
			size, err := m.CreditsAndDebits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.ProductGroups) > 0 {
		for iNdEx := len(m.ProductGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProductGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.HighlightedBreakdown != nil {
		{
			size, err := m.HighlightedBreakdown.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.InvoiceBreakdown) > 0 {
		for iNdEx := len(m.InvoiceBreakdown) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InvoiceBreakdown[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.InvoiceSummary != nil {
		{
			size, err := m.InvoiceSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Account != nil {
		{
			size, err := m.Account.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PaymentMethod) > 0 {
		i -= len(m.PaymentMethod)
		copy(dAtA[i:], m.PaymentMethod)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.PaymentMethod)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.InvoicePeriod) > 0 {
		i -= len(m.InvoicePeriod)
		copy(dAtA[i:], m.InvoicePeriod)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.InvoicePeriod)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Account) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.OutstandingBalance != nil {
		{
			size, err := m.OutstandingBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BillingAddress != nil {
		{
			size, err := m.BillingAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.InvoicePayDate) > 0 {
		i -= len(m.InvoicePayDate)
		copy(dAtA[i:], m.InvoicePayDate)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.InvoicePayDate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.JoinDate) > 0 {
		i -= len(m.JoinDate)
		copy(dAtA[i:], m.JoinDate)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.JoinDate)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccountHolder != nil {
		{
			size, err := m.AccountHolder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountHolder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountHolder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountHolder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FullName) > 0 {
		i -= len(m.FullName)
		copy(dAtA[i:], m.FullName)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.FullName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CorrespondenceName) > 0 {
		i -= len(m.CorrespondenceName)
		copy(dAtA[i:], m.CorrespondenceName)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.CorrespondenceName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AltName) > 0 {
		for iNdEx := len(m.AltName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AltName[iNdEx])
			copy(dAtA[i:], m.AltName[iNdEx])
			i = encodeVarintInvoice(dAtA, i, uint64(len(m.AltName[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressLines) > 0 {
		for iNdEx := len(m.AddressLines) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddressLines[iNdEx])
			copy(dAtA[i:], m.AddressLines[iNdEx])
			i = encodeVarintInvoice(dAtA, i, uint64(len(m.AddressLines[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Postcode) > 0 {
		i -= len(m.Postcode)
		copy(dAtA[i:], m.Postcode)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Postcode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Aggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Total != nil {
		{
			size, err := m.Total.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Section) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Section) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Section) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Total != nil {
		{
			size, err := m.Total.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.InfoMessages) > 0 {
		for iNdEx := len(m.InfoMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InfoMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Summary) > 0 {
		for iNdEx := len(m.Summary) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Summary[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CostItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CostItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CostItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Icon != nil {
		{
			size, err := m.Icon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.Cost != nil {
		{
			size, err := m.Cost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Usage != nil {
		{
			size, err := m.Usage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x52
	}
	if m.Rate != nil {
		{
			size, err := m.Rate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Prepaid {
		i--
		if m.Prepaid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Cost != nil {
		{
			size, err := m.Cost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AltUsage != nil {
		{
			size, err := m.AltUsage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Usage != nil {
		{
			size, err := m.Usage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Item_Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item_Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item_Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Usage != nil {
		{
			size, err := m.Usage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Item_Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item_Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item_Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsageClassification) > 0 {
		i -= len(m.UsageClassification)
		copy(dAtA[i:], m.UsageClassification)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.UsageClassification)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ItemType) > 0 {
		i -= len(m.ItemType)
		copy(dAtA[i:], m.ItemType)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.ItemType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InvoiceBreakdownItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvoiceBreakdownItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvoiceBreakdownItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asset != nil {
		{
			size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Cost != nil {
		{
			size, err := m.Cost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemisationSection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemisationSection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemisationSection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemisationGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemisationGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemisationGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Elements) > 0 {
		for iNdEx := len(m.Elements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Elements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemisationGroupElement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemisationGroupElement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemisationGroupElement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProductGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OffsetToOutstanding != nil {
		{
			size, err := m.OffsetToOutstanding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CreditsAndDebits != nil {
		{
			size, err := m.CreditsAndDebits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Summary) > 0 {
		for iNdEx := len(m.Summary) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Summary[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.InfoMessages) > 0 {
		for iNdEx := len(m.InfoMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InfoMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Total != nil {
		{
			size, err := m.Total.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Products) > 0 {
		for iNdEx := len(m.Products) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Products[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.InfoMessages) > 0 {
		for iNdEx := len(m.InfoMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InfoMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.Total != nil {
		{
			size, err := m.Total.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.BudgetPlan != nil {
		{
			size, err := m.BudgetPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.CreditsAndDebits != nil {
		{
			size, err := m.CreditsAndDebits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Costs != nil {
		{
			size, err := m.Costs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Histogram) > 0 {
		for iNdEx := len(m.Histogram) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Histogram[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Supply != nil {
		{
			size, err := m.Supply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Tariff != nil {
		{
			size, err := m.Tariff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.TerminationDate) > 0 {
		i -= len(m.TerminationDate)
		copy(dAtA[i:], m.TerminationDate)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.TerminationDate)))
		i--
		dAtA[i] = 0x32
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.NickName) > 0 {
		i -= len(m.NickName)
		copy(dAtA[i:], m.NickName)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.NickName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProductType) > 0 {
		i -= len(m.ProductType)
		copy(dAtA[i:], m.ProductType)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.ProductType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BudgetPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BudgetPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BudgetPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PreviousBalanceDescription) > 0 {
		i -= len(m.PreviousBalanceDescription)
		copy(dAtA[i:], m.PreviousBalanceDescription)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.PreviousBalanceDescription)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BalanceExplanation) > 0 {
		i -= len(m.BalanceExplanation)
		copy(dAtA[i:], m.BalanceExplanation)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.BalanceExplanation)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BalanceDescription) > 0 {
		i -= len(m.BalanceDescription)
		copy(dAtA[i:], m.BalanceDescription)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.BalanceDescription)))
		i--
		dAtA[i] = 0x22
	}
	if m.PreviousBalance != nil {
		{
			size, err := m.PreviousBalance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Balance != nil {
		{
			size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Total != nil {
		{
			size, err := m.Total.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Total) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Total) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Total) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Gross != nil {
		{
			size, err := m.Gross.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VatItems) > 0 {
		for iNdEx := len(m.VatItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VatItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Net != nil {
		{
			size, err := m.Net.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Supply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Supply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Supply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Distributor) > 0 {
		for iNdEx := len(m.Distributor) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Distributor[iNdEx])
			copy(dAtA[i:], m.Distributor[iNdEx])
			i = encodeVarintInvoice(dAtA, i, uint64(len(m.Distributor[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SerialNumber) > 0 {
		i -= len(m.SerialNumber)
		copy(dAtA[i:], m.SerialNumber)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.SerialNumber)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SupplyId) > 0 {
		i -= len(m.SupplyId)
		copy(dAtA[i:], m.SupplyId)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.SupplyId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tariff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tariff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tariff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInvoice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EndDate) > 0 {
		i -= len(m.EndDate)
		copy(dAtA[i:], m.EndDate)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.EndDate)))
		i--
		dAtA[i] = 0x22
	}
	if m.ExitFee != nil {
		{
			size, err := m.ExitFee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PaymentMethod) > 0 {
		i -= len(m.PaymentMethod)
		copy(dAtA[i:], m.PaymentMethod)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.PaymentMethod)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Unit) > 0 {
		i -= len(m.Unit)
		copy(dAtA[i:], m.Unit)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Unit)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cost != nil {
		{
			size, err := m.Cost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Usage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Usage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Usage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Unit) > 0 {
		i -= len(m.Unit)
		copy(dAtA[i:], m.Unit)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Unit)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlternateUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlternateUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlternateUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Factor) > 0 {
		i -= len(m.Factor)
		copy(dAtA[i:], m.Factor)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Factor)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Unit) > 0 {
		i -= len(m.Unit)
		copy(dAtA[i:], m.Unit)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Unit)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Amount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Amount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Amount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Asset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Asset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Asset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VAT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VAT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VAT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != nil {
		{
			size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInvoice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Band) > 0 {
		i -= len(m.Band)
		copy(dAtA[i:], m.Band)
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Band)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintInvoice(dAtA []byte, offset int, v uint64) int {
	offset -= sovInvoice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Invoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.InvoicePeriod)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.PaymentMethod)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.InvoiceSummary != nil {
		l = m.InvoiceSummary.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.InvoiceBreakdown) > 0 {
		for _, e := range m.InvoiceBreakdown {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.HighlightedBreakdown != nil {
		l = m.HighlightedBreakdown.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.ProductGroups) > 0 {
		for _, e := range m.ProductGroups {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.CreditsAndDebits != nil {
		l = m.CreditsAndDebits.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.InfoMessages) > 0 {
		for _, e := range m.InfoMessages {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if len(m.Addons) > 0 {
		for _, s := range m.Addons {
			l = len(s)
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.Itemisation != nil {
		l = m.Itemisation.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.AccountHolder != nil {
		l = m.AccountHolder.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.JoinDate)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.InvoicePayDate)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.BillingAddress != nil {
		l = m.BillingAddress.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.OutstandingBalance != nil {
		l = m.OutstandingBalance.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	return n
}

func (m *AccountHolder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.AltName) > 0 {
		for _, s := range m.AltName {
			l = len(s)
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	l = len(m.CorrespondenceName)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.FullName)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Postcode)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.AddressLines) > 0 {
		for _, s := range m.AddressLines {
			l = len(s)
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	return n
}

func (m *Aggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.Total != nil {
		l = m.Total.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Section) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Summary) > 0 {
		for _, e := range m.Summary {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if len(m.InfoMessages) > 0 {
		for _, e := range m.InfoMessages {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.Total != nil {
		l = m.Total.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *CostItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Icon != nil {
		l = m.Icon.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *UsageItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Usage != nil {
		l = m.Usage.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Usage != nil {
		l = m.Usage.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.AltUsage != nil {
		l = m.AltUsage.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Prepaid {
		n += 2
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Rate != nil {
		l = m.Rate.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Item_Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Usage != nil {
		l = m.Usage.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Item_Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ItemType)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.UsageClassification)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *InvoiceBreakdownItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Asset != nil {
		l = m.Asset.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *ItemisationSection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	return n
}

func (m *ItemisationGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if len(m.Elements) > 0 {
		for _, e := range m.Elements {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	return n
}

func (m *ItemisationGroupElement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	return n
}

func (m *ProductGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if len(m.Products) > 0 {
		for _, e := range m.Products {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.Total != nil {
		l = m.Total.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.InfoMessages) > 0 {
		for _, e := range m.InfoMessages {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if len(m.Summary) > 0 {
		for _, e := range m.Summary {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.CreditsAndDebits != nil {
		l = m.CreditsAndDebits.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.OffsetToOutstanding != nil {
		l = m.OffsetToOutstanding.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductType)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Active {
		n += 2
	}
	l = len(m.TerminationDate)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.Tariff != nil {
		l = m.Tariff.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Supply != nil {
		l = m.Supply.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Histogram) > 0 {
		for _, e := range m.Histogram {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.Costs != nil {
		l = m.Costs.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.CreditsAndDebits != nil {
		l = m.CreditsAndDebits.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.BudgetPlan != nil {
		l = m.BudgetPlan.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Total != nil {
		l = m.Total.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.InfoMessages) > 0 {
		for _, e := range m.InfoMessages {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 2 + l + sovInvoice(uint64(l))
		}
	}
	return n
}

func (m *BudgetPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != nil {
		l = m.Total.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Balance != nil {
		l = m.Balance.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.PreviousBalance != nil {
		l = m.PreviousBalance.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.BalanceDescription)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.BalanceExplanation)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.PreviousBalanceDescription)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Total) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Net != nil {
		l = m.Net.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.VatItems) > 0 {
		for _, e := range m.VatItems {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.Gross != nil {
		l = m.Gross.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Supply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SupplyId)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Distributor) > 0 {
		for _, s := range m.Distributor {
			l = len(s)
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Tariff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.PaymentMethod)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.ExitFee != nil {
		l = m.ExitFee.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.EndDate)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Rate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Usage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *AlternateUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Factor)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Amount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *Asset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func (m *VAT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Band)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovInvoice(uint64(l))
	}
	return n
}

func sovInvoice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInvoice(x uint64) (n int) {
	return sovInvoice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Invoice) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInvoiceBreakdown := "[]*InvoiceBreakdownItem{"
	for _, f := range this.InvoiceBreakdown {
		repeatedStringForInvoiceBreakdown += strings.Replace(f.String(), "InvoiceBreakdownItem", "InvoiceBreakdownItem", 1) + ","
	}
	repeatedStringForInvoiceBreakdown += "}"
	repeatedStringForProductGroups := "[]*ProductGroup{"
	for _, f := range this.ProductGroups {
		repeatedStringForProductGroups += strings.Replace(f.String(), "ProductGroup", "ProductGroup", 1) + ","
	}
	repeatedStringForProductGroups += "}"
	repeatedStringForInfoMessages := "[]*Asset{"
	for _, f := range this.InfoMessages {
		repeatedStringForInfoMessages += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForInfoMessages += "}"
	repeatedStringForAssets := "[]*Asset{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForAssets += "}"
	s := strings.Join([]string{`&Invoice{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`InvoicePeriod:` + fmt.Sprintf("%v", this.InvoicePeriod) + `,`,
		`PaymentMethod:` + fmt.Sprintf("%v", this.PaymentMethod) + `,`,
		`Account:` + strings.Replace(this.Account.String(), "Account", "Account", 1) + `,`,
		`InvoiceSummary:` + strings.Replace(this.InvoiceSummary.String(), "Aggregation", "Aggregation", 1) + `,`,
		`InvoiceBreakdown:` + repeatedStringForInvoiceBreakdown + `,`,
		`HighlightedBreakdown:` + strings.Replace(this.HighlightedBreakdown.String(), "Aggregation", "Aggregation", 1) + `,`,
		`ProductGroups:` + repeatedStringForProductGroups + `,`,
		`CreditsAndDebits:` + strings.Replace(this.CreditsAndDebits.String(), "Section", "Section", 1) + `,`,
		`InfoMessages:` + repeatedStringForInfoMessages + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`Addons:` + fmt.Sprintf("%v", this.Addons) + `,`,
		`Itemisation:` + strings.Replace(this.Itemisation.String(), "ItemisationSection", "ItemisationSection", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Account) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAssets := "[]*Asset{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForAssets += "}"
	s := strings.Join([]string{`&Account{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`AccountHolder:` + strings.Replace(this.AccountHolder.String(), "AccountHolder", "AccountHolder", 1) + `,`,
		`JoinDate:` + fmt.Sprintf("%v", this.JoinDate) + `,`,
		`InvoicePayDate:` + fmt.Sprintf("%v", this.InvoicePayDate) + `,`,
		`BillingAddress:` + strings.Replace(this.BillingAddress.String(), "Address", "Address", 1) + `,`,
		`OutstandingBalance:` + strings.Replace(this.OutstandingBalance.String(), "Section", "Section", 1) + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccountHolder) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccountHolder{`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`AltName:` + fmt.Sprintf("%v", this.AltName) + `,`,
		`CorrespondenceName:` + fmt.Sprintf("%v", this.CorrespondenceName) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`Phone:` + fmt.Sprintf("%v", this.Phone) + `,`,
		`FullName:` + fmt.Sprintf("%v", this.FullName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Address{`,
		`Postcode:` + fmt.Sprintf("%v", this.Postcode) + `,`,
		`AddressLines:` + fmt.Sprintf("%v", this.AddressLines) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Aggregation) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*CostItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "CostItem", "CostItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&Aggregation{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`Total:` + strings.Replace(this.Total.String(), "Total", "Total", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Section) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSummary := "[]*Aggregation{"
	for _, f := range this.Summary {
		repeatedStringForSummary += strings.Replace(f.String(), "Aggregation", "Aggregation", 1) + ","
	}
	repeatedStringForSummary += "}"
	repeatedStringForAssets := "[]*Asset{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForAssets += "}"
	repeatedStringForInfoMessages := "[]*Asset{"
	for _, f := range this.InfoMessages {
		repeatedStringForInfoMessages += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForInfoMessages += "}"
	s := strings.Join([]string{`&Section{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Summary:` + repeatedStringForSummary + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`InfoMessages:` + repeatedStringForInfoMessages + `,`,
		`Total:` + strings.Replace(this.Total.String(), "Total", "Total", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CostItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CostItem{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`Cost:` + strings.Replace(this.Cost.String(), "Total", "Total", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Icon:` + strings.Replace(this.Icon.String(), "Asset", "Asset", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UsageItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UsageItem{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Usage:` + strings.Replace(this.Usage.String(), "Usage", "Usage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Item{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Start:` + strings.Replace(fmt.Sprintf("%v", this.Start), "Item_Event", "Item_Event", 1) + `,`,
		`End:` + strings.Replace(fmt.Sprintf("%v", this.End), "Item_Event", "Item_Event", 1) + `,`,
		`Usage:` + strings.Replace(this.Usage.String(), "Usage", "Usage", 1) + `,`,
		`AltUsage:` + strings.Replace(this.AltUsage.String(), "AlternateUsage", "AlternateUsage", 1) + `,`,
		`Cost:` + strings.Replace(this.Cost.String(), "Amount", "Amount", 1) + `,`,
		`Prepaid:` + fmt.Sprintf("%v", this.Prepaid) + `,`,
		`Type:` + strings.Replace(fmt.Sprintf("%v", this.Type), "Item_Type", "Item_Type", 1) + `,`,
		`Rate:` + strings.Replace(this.Rate.String(), "Rate", "Rate", 1) + `,`,
		`Destination:` + fmt.Sprintf("%v", this.Destination) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Item_Event) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Item_Event{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Usage:` + strings.Replace(this.Usage.String(), "Usage", "Usage", 1) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Item_Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Item_Type{`,
		`ItemType:` + fmt.Sprintf("%v", this.ItemType) + `,`,
		`UsageClassification:` + fmt.Sprintf("%v", this.UsageClassification) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InvoiceBreakdownItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InvoiceBreakdownItem{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Cost:` + strings.Replace(this.Cost.String(), "Amount", "Amount", 1) + `,`,
		`Asset:` + strings.Replace(this.Asset.String(), "Asset", "Asset", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ItemisationSection) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAssets := "[]*Asset{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForAssets += "}"
	repeatedStringForGroups := "[]*ItemisationGroup{"
	for _, f := range this.Groups {
		repeatedStringForGroups += strings.Replace(f.String(), "ItemisationGroup", "ItemisationGroup", 1) + ","
	}
	repeatedStringForGroups += "}"
	s := strings.Join([]string{`&ItemisationSection{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`Groups:` + repeatedStringForGroups + `,`,
		`}`,
	}, "")
	return s
}
func (this *ItemisationGroup) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAssets := "[]*Asset{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForAssets += "}"
	repeatedStringForElements := "[]*ItemisationGroupElement{"
	for _, f := range this.Elements {
		repeatedStringForElements += strings.Replace(f.String(), "ItemisationGroupElement", "ItemisationGroupElement", 1) + ","
	}
	repeatedStringForElements += "}"
	s := strings.Join([]string{`&ItemisationGroup{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`Elements:` + repeatedStringForElements + `,`,
		`}`,
	}, "")
	return s
}
func (this *ItemisationGroupElement) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Item{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Item", "Item", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ItemisationGroupElement{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductGroup) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAssets := "[]*Asset{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForAssets += "}"
	repeatedStringForProducts := "[]*Product{"
	for _, f := range this.Products {
		repeatedStringForProducts += strings.Replace(f.String(), "Product", "Product", 1) + ","
	}
	repeatedStringForProducts += "}"
	repeatedStringForInfoMessages := "[]*Asset{"
	for _, f := range this.InfoMessages {
		repeatedStringForInfoMessages += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForInfoMessages += "}"
	repeatedStringForSummary := "[]*Aggregation{"
	for _, f := range this.Summary {
		repeatedStringForSummary += strings.Replace(f.String(), "Aggregation", "Aggregation", 1) + ","
	}
	repeatedStringForSummary += "}"
	s := strings.Join([]string{`&ProductGroup{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`Products:` + repeatedStringForProducts + `,`,
		`Total:` + strings.Replace(this.Total.String(), "Total", "Total", 1) + `,`,
		`InfoMessages:` + repeatedStringForInfoMessages + `,`,
		`Summary:` + repeatedStringForSummary + `,`,
		`CreditsAndDebits:` + strings.Replace(this.CreditsAndDebits.String(), "Aggregation", "Aggregation", 1) + `,`,
		`OffsetToOutstanding:` + strings.Replace(this.OffsetToOutstanding.String(), "Aggregation", "Aggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Product) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Item{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Item", "Item", 1) + ","
	}
	repeatedStringForItems += "}"
	repeatedStringForHistogram := "[]*UsageItem{"
	for _, f := range this.Histogram {
		repeatedStringForHistogram += strings.Replace(f.String(), "UsageItem", "UsageItem", 1) + ","
	}
	repeatedStringForHistogram += "}"
	repeatedStringForInfoMessages := "[]*Asset{"
	for _, f := range this.InfoMessages {
		repeatedStringForInfoMessages += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForInfoMessages += "}"
	repeatedStringForAssets := "[]*Asset{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForAssets += "}"
	s := strings.Join([]string{`&Product{`,
		`ProductType:` + fmt.Sprintf("%v", this.ProductType) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`NickName:` + fmt.Sprintf("%v", this.NickName) + `,`,
		`Active:` + fmt.Sprintf("%v", this.Active) + `,`,
		`TerminationDate:` + fmt.Sprintf("%v", this.TerminationDate) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`Tariff:` + strings.Replace(this.Tariff.String(), "Tariff", "Tariff", 1) + `,`,
		`Supply:` + strings.Replace(this.Supply.String(), "Supply", "Supply", 1) + `,`,
		`Histogram:` + repeatedStringForHistogram + `,`,
		`Costs:` + strings.Replace(this.Costs.String(), "Aggregation", "Aggregation", 1) + `,`,
		`CreditsAndDebits:` + strings.Replace(this.CreditsAndDebits.String(), "Aggregation", "Aggregation", 1) + `,`,
		`BudgetPlan:` + strings.Replace(this.BudgetPlan.String(), "BudgetPlan", "BudgetPlan", 1) + `,`,
		`Total:` + strings.Replace(this.Total.String(), "Total", "Total", 1) + `,`,
		`InfoMessages:` + repeatedStringForInfoMessages + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`}`,
	}, "")
	return s
}
func (this *BudgetPlan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BudgetPlan{`,
		`Total:` + strings.Replace(this.Total.String(), "Total", "Total", 1) + `,`,
		`Balance:` + strings.Replace(this.Balance.String(), "Amount", "Amount", 1) + `,`,
		`PreviousBalance:` + strings.Replace(this.PreviousBalance.String(), "Amount", "Amount", 1) + `,`,
		`BalanceDescription:` + fmt.Sprintf("%v", this.BalanceDescription) + `,`,
		`BalanceExplanation:` + fmt.Sprintf("%v", this.BalanceExplanation) + `,`,
		`PreviousBalanceDescription:` + fmt.Sprintf("%v", this.PreviousBalanceDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Total) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVatItems := "[]*VAT{"
	for _, f := range this.VatItems {
		repeatedStringForVatItems += strings.Replace(f.String(), "VAT", "VAT", 1) + ","
	}
	repeatedStringForVatItems += "}"
	s := strings.Join([]string{`&Total{`,
		`Net:` + strings.Replace(this.Net.String(), "Amount", "Amount", 1) + `,`,
		`VatItems:` + repeatedStringForVatItems + `,`,
		`Gross:` + strings.Replace(this.Gross.String(), "Amount", "Amount", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Supply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Supply{`,
		`SupplyId:` + fmt.Sprintf("%v", this.SupplyId) + `,`,
		`SerialNumber:` + fmt.Sprintf("%v", this.SerialNumber) + `,`,
		`Distributor:` + fmt.Sprintf("%v", this.Distributor) + `,`,
		`Address:` + strings.Replace(this.Address.String(), "Address", "Address", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tariff) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAssets := "[]*Asset{"
	for _, f := range this.Assets {
		repeatedStringForAssets += strings.Replace(f.String(), "Asset", "Asset", 1) + ","
	}
	repeatedStringForAssets += "}"
	s := strings.Join([]string{`&Tariff{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`PaymentMethod:` + fmt.Sprintf("%v", this.PaymentMethod) + `,`,
		`ExitFee:` + strings.Replace(this.ExitFee.String(), "Amount", "Amount", 1) + `,`,
		`EndDate:` + fmt.Sprintf("%v", this.EndDate) + `,`,
		`Assets:` + repeatedStringForAssets + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Rate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Rate{`,
		`Cost:` + strings.Replace(this.Cost.String(), "Amount", "Amount", 1) + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Usage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Usage{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AlternateUsage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AlternateUsage{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`Factor:` + fmt.Sprintf("%v", this.Factor) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Amount) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Amount{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Currency:` + fmt.Sprintf("%v", this.Currency) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Asset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Asset{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VAT) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VAT{`,
		`Band:` + fmt.Sprintf("%v", this.Band) + `,`,
		`Amount:` + strings.Replace(this.Amount.String(), "Amount", "Amount", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringInvoice(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Invoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Invoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Invoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoicePeriod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoicePeriod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &Account{}
			}
			if err := m.Account.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvoiceSummary == nil {
				m.InvoiceSummary = &Aggregation{}
			}
			if err := m.InvoiceSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceBreakdown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoiceBreakdown = append(m.InvoiceBreakdown, &InvoiceBreakdownItem{})
			if err := m.InvoiceBreakdown[len(m.InvoiceBreakdown)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighlightedBreakdown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighlightedBreakdown == nil {
				m.HighlightedBreakdown = &Aggregation{}
			}
			if err := m.HighlightedBreakdown.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductGroups = append(m.ProductGroups, &ProductGroup{})
			if err := m.ProductGroups[len(m.ProductGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditsAndDebits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreditsAndDebits == nil {
				m.CreditsAndDebits = &Section{}
			}
			if err := m.CreditsAndDebits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoMessages = append(m.InfoMessages, &Asset{})
			if err := m.InfoMessages[len(m.InfoMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addons", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addons = append(m.Addons, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itemisation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Itemisation == nil {
				m.Itemisation = &ItemisationSection{}
			}
			if err := m.Itemisation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountHolder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountHolder == nil {
				m.AccountHolder = &AccountHolder{}
			}
			if err := m.AccountHolder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoicePayDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoicePayDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BillingAddress == nil {
				m.BillingAddress = &Address{}
			}
			if err := m.BillingAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutstandingBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutstandingBalance == nil {
				m.OutstandingBalance = &Section{}
			}
			if err := m.OutstandingBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountHolder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountHolder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountHolder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AltName = append(m.AltName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrespondenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CorrespondenceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Postcode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Postcode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressLines", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressLines = append(m.AddressLines, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &CostItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Total == nil {
				m.Total = &Total{}
			}
			if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Section) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Section: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Section: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = append(m.Summary, &Aggregation{})
			if err := m.Summary[len(m.Summary)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoMessages = append(m.InfoMessages, &Asset{})
			if err := m.InfoMessages[len(m.InfoMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Total == nil {
				m.Total = &Total{}
			}
			if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CostItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CostItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CostItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &Total{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Icon == nil {
				m.Icon = &Asset{}
			}
			if err := m.Icon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Usage == nil {
				m.Usage = &Usage{}
			}
			if err := m.Usage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &Item_Event{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &Item_Event{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Usage == nil {
				m.Usage = &Usage{}
			}
			if err := m.Usage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltUsage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltUsage == nil {
				m.AltUsage = &AlternateUsage{}
			}
			if err := m.AltUsage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &Amount{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepaid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Prepaid = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Item_Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rate == nil {
				m.Rate = &Rate{}
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item_Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Usage == nil {
				m.Usage = &Usage{}
			}
			if err := m.Usage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item_Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageClassification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageClassification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvoiceBreakdownItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvoiceBreakdownItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvoiceBreakdownItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &Amount{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asset == nil {
				m.Asset = &Asset{}
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemisationSection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemisationSection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemisationSection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &ItemisationGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemisationGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemisationGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemisationGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elements = append(m.Elements, &ItemisationGroupElement{})
			if err := m.Elements[len(m.Elements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemisationGroupElement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemisationGroupElement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemisationGroupElement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Products", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Products = append(m.Products, &Product{})
			if err := m.Products[len(m.Products)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Total == nil {
				m.Total = &Total{}
			}
			if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoMessages = append(m.InfoMessages, &Asset{})
			if err := m.InfoMessages[len(m.InfoMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = append(m.Summary, &Aggregation{})
			if err := m.Summary[len(m.Summary)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditsAndDebits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreditsAndDebits == nil {
				m.CreditsAndDebits = &Aggregation{}
			}
			if err := m.CreditsAndDebits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetToOutstanding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OffsetToOutstanding == nil {
				m.OffsetToOutstanding = &Aggregation{}
			}
			if err := m.OffsetToOutstanding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminationDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TerminationDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tariff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tariff == nil {
				m.Tariff = &Tariff{}
			}
			if err := m.Tariff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Supply == nil {
				m.Supply = &Supply{}
			}
			if err := m.Supply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Histogram = append(m.Histogram, &UsageItem{})
			if err := m.Histogram[len(m.Histogram)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Costs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Costs == nil {
				m.Costs = &Aggregation{}
			}
			if err := m.Costs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditsAndDebits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreditsAndDebits == nil {
				m.CreditsAndDebits = &Aggregation{}
			}
			if err := m.CreditsAndDebits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BudgetPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BudgetPlan == nil {
				m.BudgetPlan = &BudgetPlan{}
			}
			if err := m.BudgetPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Total == nil {
				m.Total = &Total{}
			}
			if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoMessages = append(m.InfoMessages, &Asset{})
			if err := m.InfoMessages[len(m.InfoMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BudgetPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BudgetPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BudgetPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Total == nil {
				m.Total = &Total{}
			}
			if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = &Amount{}
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousBalance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousBalance == nil {
				m.PreviousBalance = &Amount{}
			}
			if err := m.PreviousBalance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceExplanation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceExplanation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousBalanceDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousBalanceDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Total) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Total: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Total: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Net == nil {
				m.Net = &Amount{}
			}
			if err := m.Net.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VatItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VatItems = append(m.VatItems, &VAT{})
			if err := m.VatItems[len(m.VatItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gross", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gross == nil {
				m.Gross = &Amount{}
			}
			if err := m.Gross.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Supply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Supply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Supply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distributor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Distributor = append(m.Distributor, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tariff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tariff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tariff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExitFee == nil {
				m.ExitFee = &Amount{}
			}
			if err := m.ExitFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &Amount{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Usage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Usage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Usage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlternateUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlternateUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlternateUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Factor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Factor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Amount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Amount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Amount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Asset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Asset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Asset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VAT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VAT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VAT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Band", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Band = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &Amount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInvoice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInvoice
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthInvoice
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInvoice
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInvoice(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthInvoice
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInvoice = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInvoice   = fmt.Errorf("proto: integer overflow")
)
